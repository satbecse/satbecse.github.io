{"version":3,"file":"speech-commands.js","sources":["../src/browser_fft_utils.ts","../src/browser_fft_extractor.ts","../src/generic_utils.ts","../src/training_utils.ts","../src/dataset.ts","../src/version.ts","../src/browser_fft_recognizer.ts","../src/index.ts"],"sourcesContent":["/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nimport {RawAudioData} from './types';\r\n\r\nexport async function loadMetadataJson(url: string):\r\n    Promise<{wordLabels: string[]}> {\r\n  return new Promise((resolve, reject) => {\r\n           const HTTP_SCHEME = 'http://';\r\n           const HTTPS_SCHEME = 'https://';\r\n           const FILE_SCHEME = 'file://';\r\n           if (url.indexOf(HTTP_SCHEME) === 0 ||\r\n               url.indexOf(HTTPS_SCHEME) === 0) {\r\n             fetch(url).then(response => {\r\n               response.json().then(parsed => resolve(parsed));\r\n             });\r\n           } else if (url.indexOf(FILE_SCHEME) === 0) {\r\n             // tslint:disable-next-line:no-require-imports\r\n             const fs = require('fs');\r\n             fs.readFile(\r\n                 url.slice(FILE_SCHEME.length), {encoding: 'utf-8'},\r\n                 (err: Error, data: string) => resolve(JSON.parse(data)));\r\n           } else {\r\n             reject(new Error(\r\n                 `Unsupported URL scheme in metadata URL: ${url}. ` +\r\n                 `Supported schemes are: http://, https://, and ` +\r\n                 `(node.js-only) file://`));\r\n           }\r\n         }) as Promise<{wordLabels: string[]}>;\r\n}\r\n\r\nlet EPSILON: number = null;\r\n\r\n/**\r\n * Normalize the input into zero mean and unit standard deviation.\r\n *\r\n * This function is safe against divison-by-zero: In case the standard\r\n * deviation is zero, the output will be all-zero.\r\n *\r\n * @param x Input tensor.\r\n * @param y Output normalized tensor.\r\n */\r\nexport function normalize(x: tf.Tensor): tf.Tensor {\r\n  if (EPSILON == null) {\r\n    EPSILON = tf.backend().epsilon();\r\n  }\r\n  return tf.tidy(() => {\r\n    const {mean, variance} = tf.moments(x);\r\n    // Add an EPSILON to the denominator to prevent division-by-zero.\r\n    return x.sub(mean).div(variance.sqrt().add(EPSILON));\r\n  });\r\n}\r\n\r\n/**\r\n * Z-Normalize the elements of a Float32Array.\r\n *\r\n * Subtract the mean and divide the result by the standard deviation.\r\n *\r\n * @param x The Float32Array to normalize.\r\n * @return Noramlzied Float32Array.\r\n */\r\nexport function normalizeFloat32Array(x: Float32Array): Float32Array {\r\n  if (x.length < 2) {\r\n    throw new Error(\r\n        'Cannot normalize a Float32Array with fewer than 2 elements.');\r\n  }\r\n  if (EPSILON == null) {\r\n    EPSILON = tf.backend().epsilon();\r\n  }\r\n  return tf.tidy(() => {\r\n    const {mean, variance} = tf.moments(tf.tensor1d(x));\r\n    const meanVal = mean.arraySync() as number;\r\n    const stdVal = Math.sqrt(variance.arraySync() as number);\r\n    const yArray = Array.from(x).map(y => (y - meanVal) / (stdVal + EPSILON));\r\n    return new Float32Array(yArray);\r\n  });\r\n}\r\n\r\nexport function getAudioContextConstructor(): AudioContext {\r\n  // tslint:disable-next-line:no-any\r\n  return (window as any).AudioContext || (window as any).webkitAudioContext;\r\n}\r\n\r\nexport async function getAudioMediaStream(\r\n    audioTrackConstraints?: MediaTrackConstraints): Promise<MediaStream> {\r\n  return await navigator.mediaDevices.getUserMedia({\r\n    audio: audioTrackConstraints == null ? true : audioTrackConstraints,\r\n    video: false\r\n  });\r\n}\r\n\r\n/**\r\n * Play raw audio waveform\r\n * @param rawAudio Raw audio data, including the waveform and the sampling rate.\r\n * @param onEnded Callback function to execute when the playing ends.\r\n */\r\nexport function playRawAudio(\r\n    rawAudio: RawAudioData, onEnded: () => void|Promise<void>): void {\r\n  const audioContextConstructor =\r\n      // tslint:disable-next-line:no-any\r\n      (window as any).AudioContext || (window as any).webkitAudioContext;\r\n  const audioContext: AudioContext = new audioContextConstructor();\r\n  const arrayBuffer =\r\n      audioContext.createBuffer(1, rawAudio.data.length, rawAudio.sampleRateHz);\r\n  const nowBuffering = arrayBuffer.getChannelData(0);\r\n  nowBuffering.set(rawAudio.data);\r\n  const source = audioContext.createBufferSource();\r\n  source.buffer = arrayBuffer;\r\n  source.connect(audioContext.destination);\r\n  source.start();\r\n  source.onended = () => {\r\n    if (onEnded != null) {\r\n      onEnded();\r\n    }\r\n  };\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\n/**\r\n * Audio FFT Feature Extractor based on Browser-Native FFT.\r\n */\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nimport {getAudioContextConstructor, getAudioMediaStream} from './browser_fft_utils';\r\nimport {FeatureExtractor, RecognizerParams} from './types';\r\n\r\nexport type SpectrogramCallback = (freqData: tf.Tensor, timeData?: tf.Tensor) =>\r\n    Promise<boolean>;\r\n\r\n/**\r\n * Configurations for constructing BrowserFftFeatureExtractor.\r\n */\r\nexport interface BrowserFftFeatureExtractorConfig extends RecognizerParams {\r\n  /**\r\n   * Number of audio frames (i.e., frequency columns) per spectrogram.\r\n   */\r\n  numFramesPerSpectrogram: number;\r\n\r\n  /**\r\n   * Suppression period in milliseconds.\r\n   *\r\n   * How much time to rest (not call the spectrogramCallback) every time\r\n   * a word with probability score above threshold is recognized.\r\n   */\r\n  suppressionTimeMillis: number;\r\n\r\n  /**\r\n   * A callback that is invoked every time a full spectrogram becomes\r\n   * available.\r\n   *\r\n   * `x` is a single-example tf.Tensor instance that includes the batch\r\n   * dimension.\r\n   * The return value is assumed to be whether a flag for whether the\r\n   * suppression period should initiate, e.g., when a word is recognized.\r\n   */\r\n  spectrogramCallback: SpectrogramCallback;\r\n\r\n  /**\r\n   * Truncate each spectrogram column at how many frequency points.\r\n   *\r\n   * If `null` or `undefined`, will do no truncation.\r\n   */\r\n  columnTruncateLength?: number;\r\n\r\n  /**\r\n   * Overlap factor. Must be >=0 and <1.\r\n   * For example, if the model takes a frame length of 1000 ms,\r\n   * and if overlap factor is 0.4, there will be a 400ms\r\n   * overlap between two successive frames, i.e., frames\r\n   * will be taken every 600 ms.\r\n   */\r\n  overlapFactor: number;\r\n\r\n  /**\r\n   * Whether to collect the raw time-domain audio waveform in addition to the\r\n   * spectrogram.\r\n   *\r\n   * Default: `false`.\r\n   */\r\n  includeRawAudio?: boolean;\r\n}\r\n\r\n/**\r\n * Audio feature extractor based on Browser-native FFT.\r\n *\r\n * Uses AudioContext and analyser node.\r\n */\r\nexport class BrowserFftFeatureExtractor implements FeatureExtractor {\r\n  // Number of frames (i.e., columns) per spectrogram used for classification.\r\n  readonly numFrames: number;\r\n\r\n  // Audio sampling rate in Hz.\r\n  readonly sampleRateHz: number;\r\n\r\n  // The FFT length for each spectrogram column.\r\n  readonly fftSize: number;\r\n\r\n  // Truncation length for spectrogram columns.\r\n  readonly columnTruncateLength: number;\r\n\r\n  // Overlapping factor: the ratio between the temporal spacing between\r\n  // consecutive spectrograms and the length of each individual spectrogram.\r\n  readonly overlapFactor: number;\r\n  readonly includeRawAudio: boolean;\r\n\r\n  private readonly spectrogramCallback: SpectrogramCallback;\r\n\r\n  private stream: MediaStream;\r\n  // tslint:disable-next-line:no-any\r\n  private audioContextConstructor: any;\r\n  private audioContext: AudioContext;\r\n  private analyser: AnalyserNode;\r\n  private tracker: Tracker;\r\n  private freqData: Float32Array;\r\n  private timeData: Float32Array;\r\n  private freqDataQueue: Float32Array[];\r\n  private timeDataQueue: Float32Array[];\r\n  // tslint:disable-next-line:no-any\r\n  private frameIntervalTask: any;\r\n  private frameDurationMillis: number;\r\n\r\n  private suppressionTimeMillis: number;\r\n\r\n  /**\r\n   * Constructor of BrowserFftFeatureExtractor.\r\n   *\r\n   * @param config Required configuration object.\r\n   */\r\n  constructor(config: BrowserFftFeatureExtractorConfig) {\r\n    if (config == null) {\r\n      throw new Error(\r\n          `Required configuration object is missing for ` +\r\n          `BrowserFftFeatureExtractor constructor`);\r\n    }\r\n\r\n    if (config.spectrogramCallback == null) {\r\n      throw new Error(`spectrogramCallback cannot be null or undefined`);\r\n    }\r\n\r\n    if (!(config.numFramesPerSpectrogram > 0)) {\r\n      throw new Error(\r\n          `Invalid value in numFramesPerSpectrogram: ` +\r\n          `${config.numFramesPerSpectrogram}`);\r\n    }\r\n\r\n    if (config.suppressionTimeMillis < 0) {\r\n      throw new Error(\r\n          `Expected suppressionTimeMillis to be >= 0, ` +\r\n          `but got ${config.suppressionTimeMillis}`);\r\n    }\r\n    this.suppressionTimeMillis = config.suppressionTimeMillis;\r\n\r\n    this.spectrogramCallback = config.spectrogramCallback;\r\n    this.numFrames = config.numFramesPerSpectrogram;\r\n    this.sampleRateHz = config.sampleRateHz || 44100;\r\n    this.fftSize = config.fftSize || 1024;\r\n    this.frameDurationMillis = this.fftSize / this.sampleRateHz * 1e3;\r\n    this.columnTruncateLength = config.columnTruncateLength || this.fftSize;\r\n    this.overlapFactor = config.overlapFactor;\r\n    this.includeRawAudio = config.includeRawAudio;\r\n\r\n    tf.util.assert(\r\n        this.overlapFactor >= 0 && this.overlapFactor < 1,\r\n        () => `Expected overlapFactor to be >= 0 and < 1, ` +\r\n            `but got ${this.overlapFactor}`);\r\n\r\n    if (this.columnTruncateLength > this.fftSize) {\r\n      throw new Error(\r\n          `columnTruncateLength ${this.columnTruncateLength} exceeds ` +\r\n          `fftSize (${this.fftSize}).`);\r\n    }\r\n\r\n    this.audioContextConstructor = getAudioContextConstructor();\r\n  }\r\n\r\n  async start(audioTrackConstraints?: MediaTrackConstraints):\r\n      Promise<Float32Array[]|void> {\r\n    if (this.frameIntervalTask != null) {\r\n      throw new Error(\r\n          'Cannot start already-started BrowserFftFeatureExtractor');\r\n    }\r\n\r\n    this.stream = await getAudioMediaStream(audioTrackConstraints);\r\n\r\n    this.audioContext = new this.audioContextConstructor() as AudioContext;\r\n    if (this.audioContext.sampleRate !== this.sampleRateHz) {\r\n      console.warn(\r\n          `Mismatch in sampling rate: ` +\r\n          `Expected: ${this.sampleRateHz}; ` +\r\n          `Actual: ${this.audioContext.sampleRate}`);\r\n    }\r\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\r\n    this.analyser = this.audioContext.createAnalyser();\r\n    this.analyser.fftSize = this.fftSize * 2;\r\n    this.analyser.smoothingTimeConstant = 0.0;\r\n    streamSource.connect(this.analyser);\r\n    // Reset the queue.\r\n    this.freqDataQueue = [];\r\n    this.freqData = new Float32Array(this.fftSize);\r\n    if (this.includeRawAudio) {\r\n      this.timeDataQueue = [];\r\n      this.timeData = new Float32Array(this.fftSize);\r\n    }\r\n    const period =\r\n        Math.max(1, Math.round(this.numFrames * (1 - this.overlapFactor)));\r\n    this.tracker = new Tracker(\r\n        period,\r\n        Math.round(this.suppressionTimeMillis / this.frameDurationMillis));\r\n    this.frameIntervalTask = setInterval(\r\n        this.onAudioFrame.bind(this), this.fftSize / this.sampleRateHz * 1e3);\r\n  }\r\n\r\n  private async onAudioFrame() {\r\n    this.analyser.getFloatFrequencyData(this.freqData);\r\n    if (this.freqData[0] === -Infinity) {\r\n      return;\r\n    }\r\n\r\n    this.freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\r\n    if (this.includeRawAudio) {\r\n      this.analyser.getFloatTimeDomainData(this.timeData);\r\n      this.timeDataQueue.push(this.timeData.slice());\r\n    }\r\n    if (this.freqDataQueue.length > this.numFrames) {\r\n      // Drop the oldest frame (least recent).\r\n      this.freqDataQueue.shift();\r\n    }\r\n    const shouldFire = this.tracker.tick();\r\n    if (shouldFire) {\r\n      const freqData = flattenQueue(this.freqDataQueue);\r\n      const freqDataTensor = getInputTensorFromFrequencyData(\r\n          freqData, [1, this.numFrames, this.columnTruncateLength, 1]);\r\n      let timeDataTensor: tf.Tensor;\r\n      if (this.includeRawAudio) {\r\n        const timeData = flattenQueue(this.timeDataQueue);\r\n        timeDataTensor = getInputTensorFromFrequencyData(\r\n            timeData, [1, this.numFrames * this.fftSize]);\r\n      }\r\n      const shouldRest =\r\n          await this.spectrogramCallback(freqDataTensor, timeDataTensor);\r\n      if (shouldRest) {\r\n        this.tracker.suppress();\r\n      }\r\n      tf.dispose([freqDataTensor, timeDataTensor]);\r\n    }\r\n  }\r\n\r\n  async stop(): Promise<void> {\r\n    if (this.frameIntervalTask == null) {\r\n      throw new Error(\r\n          'Cannot stop because there is no ongoing streaming activity.');\r\n    }\r\n    clearInterval(this.frameIntervalTask);\r\n    this.frameIntervalTask = null;\r\n    this.analyser.disconnect();\r\n    this.audioContext.close();\r\n    if (this.stream != null && this.stream.getTracks().length > 0) {\r\n      this.stream.getTracks()[0].stop();\r\n    }\r\n  }\r\n\r\n  setConfig(params: RecognizerParams) {\r\n    throw new Error(\r\n        'setConfig() is not implemented for BrowserFftFeatureExtractor.');\r\n  }\r\n\r\n  getFeatures(): Float32Array[] {\r\n    throw new Error(\r\n        'getFeatures() is not implemented for ' +\r\n        'BrowserFftFeatureExtractor. Use the spectrogramCallback ' +\r\n        'field of the constructor config instead.');\r\n  }\r\n}\r\n\r\nexport function flattenQueue(queue: Float32Array[]): Float32Array {\r\n  const frameSize = queue[0].length;\r\n  const freqData = new Float32Array(queue.length * frameSize);\r\n  queue.forEach((data, i) => freqData.set(data, i * frameSize));\r\n  return freqData;\r\n}\r\n\r\nexport function getInputTensorFromFrequencyData(\r\n    freqData: Float32Array, shape: number[]): tf.Tensor {\r\n  const vals = new Float32Array(tf.util.sizeFromShape(shape));\r\n  // If the data is less than the output shape, the rest is padded with zeros.\r\n  vals.set(freqData, vals.length - freqData.length);\r\n  return tf.tensor(vals, shape);\r\n}\r\n\r\n/**\r\n * A class that manages the firing of events based on periods\r\n * and suppression time.\r\n */\r\nexport class Tracker {\r\n  readonly period: number;\r\n  readonly suppressionTime: number;\r\n\r\n  private counter: number;\r\n  private suppressionOnset: number;\r\n\r\n  /**\r\n   * Constructor of Tracker.\r\n   *\r\n   * @param period The event-firing period, in number of frames.\r\n   * @param suppressionPeriod The suppression period, in number of frames.\r\n   */\r\n  constructor(period: number, suppressionPeriod: number) {\r\n    this.period = period;\r\n    this.suppressionTime = suppressionPeriod == null ? 0 : suppressionPeriod;\r\n    this.counter = 0;\r\n\r\n    tf.util.assert(\r\n        this.period > 0,\r\n        () => `Expected period to be positive, but got ${this.period}`);\r\n  }\r\n\r\n  /**\r\n   * Mark a frame.\r\n   *\r\n   * @returns Whether the event should be fired at the current frame.\r\n   */\r\n  tick(): boolean {\r\n    this.counter++;\r\n    const shouldFire = (this.counter % this.period === 0) &&\r\n        (this.suppressionOnset == null ||\r\n         this.counter - this.suppressionOnset > this.suppressionTime);\r\n    return shouldFire;\r\n  }\r\n\r\n  /**\r\n   * Order the beginning of a supression period.\r\n   */\r\n  suppress() {\r\n    this.suppressionOnset = this.counter;\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\n/**\r\n * Concatenate a number of ArrayBuffers into one.\r\n *\r\n * @param buffers A number of array buffers to concatenate.\r\n * @returns Result of concatenating `buffers` in order.\r\n */\r\nexport function concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {\r\n  let totalByteLength = 0;\r\n  buffers.forEach((buffer: ArrayBuffer) => {\r\n    totalByteLength += buffer.byteLength;\r\n  });\r\n\r\n  const temp = new Uint8Array(totalByteLength);\r\n  let offset = 0;\r\n  buffers.forEach((buffer: ArrayBuffer) => {\r\n    temp.set(new Uint8Array(buffer), offset);\r\n    offset += buffer.byteLength;\r\n  });\r\n  return temp.buffer;\r\n}\r\n\r\n/**\r\n * Concatenate Float32Arrays.\r\n *\r\n * @param xs Float32Arrays to concatenate.\r\n * @return The result of the concatenation.\r\n */\r\nexport function concatenateFloat32Arrays(xs: Float32Array[]): Float32Array {\r\n  let totalLength = 0;\r\n  xs.forEach(x => totalLength += x.length);\r\n  const concatenated = new Float32Array(totalLength);\r\n  let index = 0;\r\n  xs.forEach(x => {\r\n    concatenated.set(x, index);\r\n    index += x.length;\r\n  });\r\n  return concatenated;\r\n}\r\n\r\n/** Encode a string as an ArrayBuffer. */\r\nexport function string2ArrayBuffer(str: string): ArrayBuffer {\r\n  if (str == null) {\r\n    throw new Error('Received null or undefind string');\r\n  }\r\n  // NOTE(cais): This implementation is inefficient in terms of memory.\r\n  // But it works for UTF-8 strings. Just don't use on for very long strings.\r\n  const strUTF8 = unescape(encodeURIComponent(str));\r\n  const buf = new Uint8Array(strUTF8.length);\r\n  for (let i = 0; i < strUTF8.length; ++i) {\r\n    buf[i] = strUTF8.charCodeAt(i);\r\n  }\r\n  return buf.buffer;\r\n}\r\n\r\n/** Decode an ArrayBuffer as a string. */\r\nexport function arrayBuffer2String(buffer: ArrayBuffer): string {\r\n  if (buffer == null) {\r\n    throw new Error('Received null or undefind buffer');\r\n  }\r\n  const buf = new Uint8Array(buffer);\r\n  return decodeURIComponent(escape(String.fromCharCode(...buf)));\r\n}\r\n\r\n/** Generate a pseudo-random UID. */\r\nexport function getUID(): string {\r\n  function s4() {\r\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\r\n  }\r\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() +\r\n      s4() + s4();\r\n}\r\n\r\nexport function getRandomInteger(min: number, max: number): number {\r\n  return Math.floor((max - min) * Math.random()) + min;\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\n/**\r\n * Utility functions for training and transfer learning of the speech-commands\r\n * model.\r\n */\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\n/**\r\n * Split feature and target tensors into train and validation (val) splits.\r\n *\r\n * Given sufficent number of examples, the train and val sets will be\r\n * balanced with respect to the classes.\r\n *\r\n * @param xs Features tensor, of shape [numExamples, ...].\r\n * @param ys Targets tensors, of shape [numExamples, numClasses]. Assumed to be\r\n *   one-hot categorical encoding.\r\n * @param valSplit A number > 0 and < 1, fraction of examples to use\r\n *   as the validation set.\r\n * @returns trainXs: training features tensor; trainYs: training targets\r\n *   tensor; valXs: validation features tensor; valYs: validation targets\r\n *   tensor.\r\n */\r\nexport function balancedTrainValSplit(\r\n    xs: tf.Tensor, ys: tf.Tensor, valSplit: number): {\r\n  trainXs: tf.Tensor,\r\n  trainYs: tf.Tensor,\r\n  valXs: tf.Tensor,\r\n  valYs: tf.Tensor\r\n} {\r\n  tf.util.assert(\r\n      valSplit > 0 && valSplit < 1,\r\n      () => `validationSplit is expected to be >0 and <1, ` +\r\n          `but got ${valSplit}`);\r\n\r\n  return tf.tidy(() => {\r\n    const classIndices = ys.argMax(-1).dataSync();\r\n\r\n    const indicesByClasses: number[][] = [];\r\n    for (let i = 0; i < classIndices.length; ++i) {\r\n      const classIndex = classIndices[i];\r\n      if (indicesByClasses[classIndex] == null) {\r\n        indicesByClasses[classIndex] = [];\r\n      }\r\n      indicesByClasses[classIndex].push(i);\r\n    }\r\n    const numClasses = indicesByClasses.length;\r\n\r\n    const trainIndices: number[] = [];\r\n    const valIndices: number[] = [];\r\n\r\n    // Randomly shuffle the list of indices in each array.\r\n    indicesByClasses.map(classIndices => tf.util.shuffle(classIndices));\r\n    for (let i = 0; i < numClasses; ++i) {\r\n      const classIndices = indicesByClasses[i];\r\n      const cutoff = Math.round(classIndices.length * (1 - valSplit));\r\n      for (let j = 0; j < classIndices.length; ++j) {\r\n        if (j < cutoff) {\r\n          trainIndices.push(classIndices[j]);\r\n        } else {\r\n          valIndices.push(classIndices[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    const trainXs = tf.gather(xs, trainIndices);\r\n    const trainYs = tf.gather(ys, trainIndices);\r\n    const valXs = tf.gather(xs, valIndices);\r\n    const valYs = tf.gather(ys, valIndices);\r\n    return {trainXs, trainYs, valXs, valYs};\r\n  });\r\n}\r\n\r\n/**\r\n * Same as balancedTrainValSplit, but for number arrays or Float32Arrays.\r\n */\r\nexport function balancedTrainValSplitNumArrays(\r\n    xs: number[][]|Float32Array[], ys: number[], valSplit: number): {\r\n  trainXs: number[][]|Float32Array[],\r\n  trainYs: number[],\r\n  valXs: number[][]|Float32Array[],\r\n  valYs: number[]\r\n} {\r\n  tf.util.assert(\r\n      valSplit > 0 && valSplit < 1,\r\n      () => `validationSplit is expected to be >0 and <1, ` +\r\n          `but got ${valSplit}`);\r\n  const isXsFloat32Array = !Array.isArray(xs[0]);\r\n\r\n  const classIndices = ys;\r\n\r\n  const indicesByClasses: number[][] = [];\r\n  for (let i = 0; i < classIndices.length; ++i) {\r\n    const classIndex = classIndices[i];\r\n    if (indicesByClasses[classIndex] == null) {\r\n      indicesByClasses[classIndex] = [];\r\n    }\r\n    indicesByClasses[classIndex].push(i);\r\n  }\r\n  const numClasses = indicesByClasses.length;\r\n\r\n  const trainIndices: number[] = [];\r\n  const valIndices: number[] = [];\r\n\r\n  // Randomly shuffle the list of indices in each array.\r\n  indicesByClasses.map(classIndices => tf.util.shuffle(classIndices));\r\n  for (let i = 0; i < numClasses; ++i) {\r\n    const classIndices = indicesByClasses[i];\r\n    const cutoff = Math.round(classIndices.length * (1 - valSplit));\r\n    for (let j = 0; j < classIndices.length; ++j) {\r\n      if (j < cutoff) {\r\n        trainIndices.push(classIndices[j]);\r\n      } else {\r\n        valIndices.push(classIndices[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isXsFloat32Array) {\r\n    const trainXs: Float32Array[] = [];\r\n    const trainYs: number[] = [];\r\n    const valXs: Float32Array[] = [];\r\n    const valYs: number[] = [];\r\n    for (const index of trainIndices) {\r\n      trainXs.push(xs[index] as Float32Array);\r\n      trainYs.push(ys[index]);\r\n    }\r\n    for (const index of valIndices) {\r\n      valXs.push(xs[index] as Float32Array);\r\n      valYs.push(ys[index]);\r\n    }\r\n    return {trainXs, trainYs, valXs, valYs};\r\n  } else {\r\n    const trainXs: number[][] = [];\r\n    const trainYs: number[] = [];\r\n    const valXs: number[][] = [];\r\n    const valYs: number[] = [];\r\n    for (const index of trainIndices) {\r\n      trainXs.push(xs[index] as number[]);\r\n      trainYs.push(ys[index]);\r\n    }\r\n    for (const index of valIndices) {\r\n      valXs.push(xs[index] as number[]);\r\n      valYs.push(ys[index]);\r\n    }\r\n    return {trainXs, trainYs, valXs, valYs};\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\nimport {normalize} from './browser_fft_utils';\r\nimport {arrayBuffer2String, concatenateArrayBuffers, getRandomInteger, getUID, string2ArrayBuffer} from './generic_utils';\r\nimport {balancedTrainValSplitNumArrays} from './training_utils';\r\nimport {AudioDataAugmentationOptions, Example, SpectrogramData} from './types';\r\n\r\n// Descriptor for serialized dataset files: stands for:\r\n//   TensorFlow.js Speech-Commands Dataset.\r\n// DO NOT EVER CHANGE THIS!\r\nexport const DATASET_SERIALIZATION_DESCRIPTOR = 'TFJSSCDS';\r\n\r\n// A version number for the serialization. Since this needs\r\n// to be encoded within a length-1 Uint8 array, it must be\r\n//   1. an positive integer.\r\n//   2. monotonically increasing over its change history.\r\n// Item 1 is checked by unit tests.\r\nexport const DATASET_SERIALIZATION_VERSION = 1;\r\n\r\n/**\r\n * Specification for an `Example` (see above).\r\n *\r\n * Used for serialization of `Example`.\r\n */\r\nexport interface ExampleSpec {\r\n  /** A label for the example. */\r\n  label: string;\r\n\r\n  /** Number of frames in the spectrogram. */\r\n  spectrogramNumFrames: number;\r\n\r\n  /** The length of each frame in the spectrogram. */\r\n  spectrogramFrameSize: number;\r\n\r\n  /** The key frame index of the spectrogram. */\r\n  spectrogramKeyFrameIndex?: number;\r\n\r\n  /** Number of samples in the raw PCM-format audio (if any). */\r\n  rawAudioNumSamples?: number;\r\n\r\n  /** Sampling rate of the raw audio (if any). */\r\n  rawAudioSampleRateHz?: number;\r\n}\r\n\r\n/**\r\n * Serialized Dataset, containing a number of `Example`s in their\r\n * serialized format.\r\n *\r\n * This format consists of a plain-old JSON object as the manifest,\r\n * along with a flattened binary `ArrayBuffer`. The format facilitates\r\n * storage and transmission.\r\n */\r\nexport interface SerializedExamples {\r\n  /**\r\n   * Specifications of the serialized `Example`s, serialized as a string.\r\n   */\r\n  manifest: ExampleSpec[];\r\n\r\n  /**\r\n   * Serialized binary data from the `Example`s.\r\n   *\r\n   * Including the spectrograms and the raw audio (if any).\r\n   *\r\n   * For example, assuming `manifest.length` is `N`, the format of the\r\n   * `ArrayBuffer` is as follows:\r\n   *\r\n   *   [spectrogramData1, rawAudio1 (if any),\r\n   *    spectrogramData2, rawAudio2 (if any),\r\n   *    ...\r\n   *    spectrogramDataN, rawAudioN (if any)]\r\n   */\r\n  data: ArrayBuffer;\r\n}\r\n\r\nexport const BACKGROUND_NOISE_TAG = '_background_noise_';\r\n\r\n/**\r\n * Configuration for getting spectrograms as tensors.\r\n */\r\nexport interface GetDataConfig extends AudioDataAugmentationOptions {\r\n  /**\r\n   * Number of frames.\r\n   *\r\n   * This must be smaller than or equal to the # of frames of each\r\n   * example held by the dataset.\r\n   *\r\n   * If the # of frames of an example is greater than this number,\r\n   * the following heuristics will be used to extra >= 1 examples\r\n   * of length numFrames from the original example:\r\n   *\r\n   *   - If the label of the example is `BAKCGROUND_NOISE_TAG`,\r\n   *     the example will be splitted into multiple examples using the\r\n   *     `hopFrames` parameter (see below).\r\n   *   - If the label of the example is not `BACKGROUND_NOISE_TAG`,\r\n   *     the example will be splitted into multiple examples that\r\n   *     all contain the maximum-intensity frame using the `hopFrames`\r\n   *     parameter.\r\n   */\r\n  numFrames?: number;\r\n\r\n  /**\r\n   * Hop length in number of frames.\r\n   *\r\n   * Used when splitting a long example into multiple shorter ones.\r\n   *\r\n   * Must be provided if any such long examples exist.\r\n   */\r\n  hopFrames?: number;\r\n\r\n  /**\r\n   * Whether the spectrogram of each example will be normalized.\r\n   *\r\n   * Normalization means:\r\n   * - Subtracting the mean, and\r\n   * - Dividing the result by the standard deviation.\r\n   *\r\n   * Default: `true`.\r\n   */\r\n  normalize?: boolean;\r\n\r\n  /**\r\n   * Whether the examples will be shuffled prior to merged into\r\n   * `tf.Tensor`s.\r\n   *\r\n   * Default: `true`.\r\n   */\r\n  shuffle?: boolean;\r\n\r\n  /**\r\n   * Whether to obtain a `tf.data.Datasaet` object.\r\n   *\r\n   * Default: `false`.\r\n   */\r\n  getDataset?: boolean;\r\n\r\n  /**\r\n   * Batch size for dataset.\r\n   *\r\n   * Applicable only if `getDataset === true`.\r\n   */\r\n  datasetBatchSize?: number;\r\n\r\n  /**\r\n   * Validation split for the datasaet.\r\n   *\r\n   * Applicable only if `getDataset === true`.\r\n   *\r\n   * The data will be divided into two fractions of relative sizes\r\n   * `[1 - datasetValidationSplit, datasetValidationSplit]`, for the\r\n   * training and validation `tf.data.Dataset` objects, respectively.\r\n   *\r\n   * Must be a number between 0 and 1.\r\n   * Default: 0.15.\r\n   */\r\n  datasetValidationSplit?: number;\r\n}\r\n\r\n// tslint:disable-next-line:no-any\r\nexport type SpectrogramAndTargetsTfDataset = tf.data.Dataset<{}>;\r\n\r\n/**\r\n * A serializable, mutable set of speech/audio `Example`s;\r\n */\r\nexport class Dataset {\r\n  private examples: {[id: string]: Example};\r\n  private label2Ids: {[label: string]: string[]};\r\n\r\n  /**\r\n   * Constructor of `Dataset`.\r\n   *\r\n   * If called with no arguments (i.e., `artifacts` == null), an empty dataset\r\n   * will be constructed.\r\n   *\r\n   * Else, the dataset will be deserialized from `artifacts`.\r\n   *\r\n   * @param serialized Optional serialization artifacts to deserialize.\r\n   */\r\n  constructor(serialized?: ArrayBuffer) {\r\n    this.examples = {};\r\n    this.label2Ids = {};\r\n    if (serialized != null) {\r\n      // Deserialize from the provided artifacts.\r\n      const artifacts = arrayBuffer2SerializedExamples(serialized);\r\n      let offset = 0;\r\n      for (let i = 0; i < artifacts.manifest.length; ++i) {\r\n        const spec = artifacts.manifest[i];\r\n        let byteLen = spec.spectrogramNumFrames * spec.spectrogramFrameSize;\r\n        if (spec.rawAudioNumSamples != null) {\r\n          byteLen += spec.rawAudioNumSamples;\r\n        }\r\n        byteLen *= 4;\r\n        this.addExample(deserializeExample(\r\n            {spec, data: artifacts.data.slice(offset, offset + byteLen)}));\r\n        offset += byteLen;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add an `Example` to the `Dataset`\r\n   *\r\n   * @param example A `Example`, with a label. The label must be a non-empty\r\n   *   string.\r\n   * @returns The UID for the added `Example`.\r\n   */\r\n  addExample(example: Example): string {\r\n    tf.util.assert(example != null, () => 'Got null or undefined example');\r\n    tf.util.assert(\r\n        example.label != null && example.label.length > 0,\r\n        () => `Expected label to be a non-empty string, ` +\r\n            `but got ${JSON.stringify(example.label)}`);\r\n    const uid = getUID();\r\n    this.examples[uid] = example;\r\n    if (!(example.label in this.label2Ids)) {\r\n      this.label2Ids[example.label] = [];\r\n    }\r\n    this.label2Ids[example.label].push(uid);\r\n    return uid;\r\n  }\r\n\r\n  /**\r\n   * Merge the incoming dataset into this dataset\r\n   *\r\n   * @param dataset The incoming dataset to be merged into this dataset.\r\n   */\r\n  merge(dataset: Dataset): void {\r\n    tf.util.assert(\r\n        dataset !== this, () => 'Cannot merge a dataset into itself');\r\n    const vocab = dataset.getVocabulary();\r\n    for (const word of vocab) {\r\n      const examples = dataset.getExamples(word);\r\n      for (const example of examples) {\r\n        this.addExample(example.example);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a map from `Example` label to number of `Example`s with the label.\r\n   *\r\n   * @returns A map from label to number of example counts under that label.\r\n   */\r\n  getExampleCounts(): {[label: string]: number} {\r\n    const counts: {[label: string]: number} = {};\r\n    for (const uid in this.examples) {\r\n      const example = this.examples[uid];\r\n      if (!(example.label in counts)) {\r\n        counts[example.label] = 0;\r\n      }\r\n      counts[example.label]++;\r\n    }\r\n    return counts;\r\n  }\r\n\r\n  /**\r\n   * Get all examples of a given label, with their UIDs.\r\n   *\r\n   * @param label The requested label.\r\n   * @return All examples of the given `label`, along with their UIDs.\r\n   *   The examples are sorted in the order in which they are added to the\r\n   *   `Dataset`.\r\n   * @throws Error if label is `null` or `undefined`.\r\n   */\r\n  getExamples(label: string): Array<{uid: string, example: Example}> {\r\n    tf.util.assert(\r\n        label != null,\r\n        () =>\r\n            `Expected label to be a string, but got ${JSON.stringify(label)}`);\r\n    tf.util.assert(\r\n        label in this.label2Ids,\r\n        () => `No example of label \"${label}\" exists in dataset`);\r\n    const output: Array<{uid: string, example: Example}> = [];\r\n    this.label2Ids[label].forEach(id => {\r\n      output.push({uid: id, example: this.examples[id]});\r\n    });\r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Get all examples and labels as tensors.\r\n   *\r\n   * - If `label` is provided and exists in the vocabulary of the `Dataset`,\r\n   *   the spectrograms of all `Example`s under the `label` will be returned\r\n   *   as a 4D `tf.Tensor` as `xs`. The shape of the `tf.Tensor` will be\r\n   *     `[numExamples, numFrames, frameSize, 1]`\r\n   *   where\r\n   *     - `numExamples` is the number of `Example`s with the label\r\n   *     - `numFrames` is the number of frames in each spectrogram\r\n   *     - `frameSize` is the size of each spectrogram frame.\r\n   *   No label Tensor will be returned.\r\n   * - If `label` is not provided, all `Example`s will be returned as `xs`.\r\n   *   In addition, `ys` will contain a one-hot encoded list of labels.\r\n   *   - The shape of `xs` will be: `[numExamples, numFrames, frameSize, 1]`\r\n   *   - The shape of `ys` will be: `[numExamples, vocabularySize]`.\r\n   *\r\n   * @returns If `config.getDataset` is `true`, returns two `tf.data.Dataset`\r\n   *   objects, one for training and one for validation.\r\n   *   Else, xs` and `ys` tensors. See description above.\r\n   * @throws Error\r\n   *   - if not all the involved spectrograms have matching `numFrames` and\r\n   *     `frameSize`, or\r\n   *   - if `label` is provided and is not present in the vocabulary of the\r\n   *     `Dataset`, or\r\n   *   - if the `Dataset` is currently empty.\r\n   */\r\n  getData(label?: string, config?: GetDataConfig): {\r\n    xs: tf.Tensor4D,\r\n    ys?: tf.Tensor2D\r\n  }|[SpectrogramAndTargetsTfDataset, SpectrogramAndTargetsTfDataset] {\r\n    tf.util.assert(\r\n        this.size() > 0,\r\n        () =>\r\n            `Cannot get spectrograms as tensors because the dataset is empty`);\r\n    const vocab = this.getVocabulary();\r\n    if (label != null) {\r\n      tf.util.assert(\r\n          vocab.indexOf(label) !== -1,\r\n          () => `Label ${label} is not in the vocabulary ` +\r\n              `(${JSON.stringify(vocab)})`);\r\n    } else {\r\n      // If all words are requested, there must be at least two words in the\r\n      // vocabulary to make one-hot encoding possible.\r\n      tf.util.assert(\r\n          vocab.length > 1,\r\n          () => `One-hot encoding of labels requires the vocabulary to have ` +\r\n              `at least two words, but it has only ${vocab.length} word.`);\r\n    }\r\n\r\n    if (config == null) {\r\n      config = {};\r\n    }\r\n\r\n    // Get the numFrames lengths of all the examples currently held by the\r\n    // dataset.\r\n    const sortedUniqueNumFrames = this.getSortedUniqueNumFrames();\r\n    let numFrames: number;\r\n    let hopFrames: number;\r\n    if (sortedUniqueNumFrames.length === 1) {\r\n      numFrames = config.numFrames == null ? sortedUniqueNumFrames[0] :\r\n                                             config.numFrames;\r\n      hopFrames = config.hopFrames == null ? 1 : config.hopFrames;\r\n    } else {\r\n      numFrames = config.numFrames;\r\n      tf.util.assert(\r\n          numFrames != null && Number.isInteger(numFrames) && numFrames > 0,\r\n          () => `There are ${\r\n                    sortedUniqueNumFrames.length} unique lengths among ` +\r\n              `the ${this.size()} examples of this Dataset, hence numFrames ` +\r\n              `is required. But it is not provided.`);\r\n      tf.util.assert(\r\n          numFrames <= sortedUniqueNumFrames[0],\r\n          () => `numFrames (${numFrames}) exceeds the minimum numFrames ` +\r\n              `(${sortedUniqueNumFrames[0]}) among the examples of ` +\r\n              `the Dataset.`);\r\n\r\n      hopFrames = config.hopFrames;\r\n      tf.util.assert(\r\n          hopFrames != null && Number.isInteger(hopFrames) && hopFrames > 0,\r\n          () => `There are ${\r\n                    sortedUniqueNumFrames.length} unique lengths among ` +\r\n              `the ${this.size()} examples of this Dataset, hence hopFrames ` +\r\n              `is required. But it is not provided.`);\r\n    }\r\n\r\n    // Normalization is performed by default.\r\n    const toNormalize = config.normalize == null ? true : config.normalize;\r\n\r\n    return tf.tidy(() => {\r\n      let xTensors: tf.Tensor3D[] = [];\r\n      let xArrays: Float32Array[] = [];\r\n\r\n      let labelIndices: number[] = [];\r\n      let uniqueFrameSize: number;\r\n      for (let i = 0; i < vocab.length; ++i) {\r\n        const currentLabel = vocab[i];\r\n        if (label != null && currentLabel !== label) {\r\n          continue;\r\n        }\r\n        const ids = this.label2Ids[currentLabel];\r\n        for (const id of ids) {\r\n          const example = this.examples[id];\r\n          const spectrogram = example.spectrogram;\r\n          const frameSize = spectrogram.frameSize;\r\n          if (uniqueFrameSize == null) {\r\n            uniqueFrameSize = frameSize;\r\n          } else {\r\n            tf.util.assert(\r\n                frameSize === uniqueFrameSize,\r\n                () => `Mismatch in frameSize  ` +\r\n                    `(${frameSize} vs ${uniqueFrameSize})`);\r\n          }\r\n\r\n          const snippetLength = spectrogram.data.length / frameSize;\r\n          let focusIndex = null;\r\n          if (currentLabel !== BACKGROUND_NOISE_TAG) {\r\n            focusIndex = spectrogram.keyFrameIndex == null ?\r\n                getMaxIntensityFrameIndex(spectrogram).dataSync()[0] :\r\n                spectrogram.keyFrameIndex;\r\n          }\r\n          // TODO(cais): See if we can get rid of dataSync();\r\n\r\n          const snippet =\r\n              tf.tensor3d(spectrogram.data, [snippetLength, frameSize, 1]);\r\n          const windows =\r\n              getValidWindows(snippetLength, focusIndex, numFrames, hopFrames);\r\n          for (const window of windows) {\r\n            const windowedSnippet = tf.tidy(() => {\r\n              const output = snippet.slice(\r\n                  [window[0], 0, 0], [window[1] - window[0], -1, -1]);\r\n              return toNormalize ? normalize(output) : output;\r\n            });\r\n            if (config.getDataset) {\r\n              // TODO(cais): See if we can do away with dataSync();\r\n              // TODO(cais): Shuffling?\r\n              xArrays.push(windowedSnippet.dataSync() as Float32Array);\r\n            } else {\r\n              xTensors.push(windowedSnippet as tf.Tensor3D);\r\n            }\r\n            if (label == null) {\r\n              labelIndices.push(i);\r\n            }\r\n          }\r\n          tf.dispose(snippet);  // For memory saving.\r\n        }\r\n      }\r\n\r\n      if (config.augmentByMixingNoiseRatio != null) {\r\n        this.augmentByMixingNoise(\r\n            config.getDataset ? xArrays : xTensors as\r\n                Array<Float32Array | tf.Tensor>,\r\n            labelIndices, config.augmentByMixingNoiseRatio);\r\n      }\r\n\r\n      const shuffle = config.shuffle == null ? true : config.shuffle;\r\n      if (config.getDataset) {\r\n        const batchSize =\r\n            config.datasetBatchSize == null ? 32 : config.datasetBatchSize;\r\n\r\n        // Split the data into two splits: training and validation.\r\n        const valSplit = config.datasetValidationSplit == null ?\r\n            0.15 :\r\n            config.datasetValidationSplit;\r\n        tf.util.assert(\r\n            valSplit > 0 && valSplit < 1,\r\n            () => `Invalid dataset validation split: ${valSplit}`);\r\n\r\n        const zippedXandYArrays =\r\n            xArrays.map((xArray, i) => [xArray, labelIndices[i]]);\r\n        tf.util.shuffle(\r\n            zippedXandYArrays);  // Shuffle the data before splitting.\r\n        xArrays = zippedXandYArrays.map(item => item[0]) as Float32Array[];\r\n        const yArrays = zippedXandYArrays.map(item => item[1]) as number[];\r\n        const {trainXs, trainYs, valXs, valYs} =\r\n            balancedTrainValSplitNumArrays(xArrays, yArrays, valSplit);\r\n\r\n        // TODO(cais): The typing around Float32Array is not working properly\r\n        // for tf.data currently. Tighten the types when the tf.data bug is\r\n        // fixed.\r\n        // tslint:disable:no-any\r\n        const xTrain =\r\n            tf.data.array(trainXs as any).map(x => tf.tensor3d(x as any, [\r\n              numFrames, uniqueFrameSize, 1\r\n            ]));\r\n        const yTrain = tf.data.array(trainYs).map(\r\n            y => tf.oneHot([y], vocab.length).squeeze([0]));\r\n        // TODO(cais): See if we can tighten the typing.\r\n        let trainDataset = tf.data.zip({xs: xTrain, ys: yTrain});\r\n        if (shuffle) {\r\n          // Shuffle the dataset.\r\n          trainDataset = trainDataset.shuffle(xArrays.length);\r\n        }\r\n        trainDataset = trainDataset.batch(batchSize).prefetch(4);\r\n\r\n        const xVal =\r\n            tf.data.array(valXs as any).map(x => tf.tensor3d(x as any, [\r\n              numFrames, uniqueFrameSize, 1\r\n            ]));\r\n        const yVal = tf.data.array(valYs).map(\r\n            y => tf.oneHot([y], vocab.length).squeeze([0]));\r\n        let valDataset = tf.data.zip({xs: xVal, ys: yVal});\r\n        valDataset = valDataset.batch(batchSize).prefetch(4);\r\n        // tslint:enable:no-any\r\n\r\n        // tslint:disable-next-line:no-any\r\n        return [trainDataset, valDataset] as any;\r\n      } else {\r\n        if (shuffle) {\r\n          // Shuffle the data.\r\n          const zipped: Array<{x: tf.Tensor3D, y: number}> = [];\r\n          xTensors.forEach((xTensor, i) => {\r\n            zipped.push({x: xTensor, y: labelIndices[i]});\r\n          });\r\n          tf.util.shuffle(zipped);\r\n          xTensors = zipped.map(item => item.x);\r\n          labelIndices = zipped.map(item => item.y);\r\n        }\r\n\r\n        const targets = label == null ?\r\n            tf.oneHot(tf.tensor1d(labelIndices, 'int32'), vocab.length)\r\n                .asType('float32') :\r\n            undefined;\r\n        return {\r\n          xs: tf.stack(xTensors) as tf.Tensor4D,\r\n          ys: targets as tf.Tensor2D\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  private augmentByMixingNoise<T extends tf.Tensor | Float32Array>(\r\n      xs: T[], labelIndices: number[], ratio: number): void {\r\n    if (xs == null || xs.length === 0) {\r\n      throw new Error(\r\n          `Cannot perform augmentation because data is null or empty`);\r\n    }\r\n    const isTypedArray = xs[0] instanceof Float32Array;\r\n\r\n    const vocab = this.getVocabulary();\r\n    const noiseExampleIndices: number[] = [];\r\n    const wordExampleIndices: number[] = [];\r\n    for (let i = 0; i < labelIndices.length; ++i) {\r\n      if (vocab[labelIndices[i]] === BACKGROUND_NOISE_TAG) {\r\n        noiseExampleIndices.push(i);\r\n      } else {\r\n        wordExampleIndices.push(i);\r\n      }\r\n    }\r\n    if (noiseExampleIndices.length === 0) {\r\n      throw new Error(\r\n          `Cannot perform augmentation by mixing with noise when ` +\r\n          `there is no example with label ${BACKGROUND_NOISE_TAG}`);\r\n    }\r\n\r\n    const mixedXTensors: Array<tf.Tensor | Float32Array> = [];\r\n    const mixedLabelIndices: number[] = [];\r\n    for (const index of wordExampleIndices) {\r\n      const noiseIndex =  // Randomly sample from the noises, with replacement.\r\n          noiseExampleIndices[getRandomInteger(0, noiseExampleIndices.length)];\r\n      const signalTensor = isTypedArray ?\r\n          tf.tensor1d(xs[index] as Float32Array) : xs[index] as tf.Tensor;\r\n      const noiseTensor = isTypedArray ?\r\n          tf.tensor1d(xs[noiseIndex] as Float32Array) :\r\n          xs[noiseIndex] as tf.Tensor;\r\n      const mixed: tf.Tensor = tf.tidy(() =>\r\n          normalize(signalTensor.add(noiseTensor.mul(ratio))));\r\n      if (isTypedArray) {\r\n        mixedXTensors.push(mixed.dataSync() as Float32Array);\r\n      } else {\r\n        mixedXTensors.push(mixed);\r\n      }\r\n      mixedLabelIndices.push(labelIndices[index]);\r\n    }\r\n    console.log(\r\n        `Data augmentation: mixing noise: added ${mixedXTensors.length} ` +\r\n        `examples`);\r\n    mixedXTensors.forEach(tensor => xs.push(tensor as T));\r\n    labelIndices.push(...mixedLabelIndices);\r\n  }\r\n\r\n  private getSortedUniqueNumFrames(): number[] {\r\n    const numFramesSet = new Set<number>();\r\n    const vocab = this.getVocabulary();\r\n    for (let i = 0; i < vocab.length; ++i) {\r\n      const label = vocab[i];\r\n      const ids = this.label2Ids[label];\r\n      for (const id of ids) {\r\n        const spectrogram = this.examples[id].spectrogram;\r\n        const numFrames = spectrogram.data.length / spectrogram.frameSize;\r\n        numFramesSet.add(numFrames);\r\n      }\r\n    }\r\n    const uniqueNumFrames = [...numFramesSet];\r\n    uniqueNumFrames.sort();\r\n    return uniqueNumFrames;\r\n  }\r\n\r\n  /**\r\n   * Remove an example from the `Dataset`.\r\n   *\r\n   * @param uid The UID of the example to remove.\r\n   * @throws Error if the UID doesn't exist in the `Dataset`.\r\n   */\r\n  removeExample(uid: string): void {\r\n    if (!(uid in this.examples)) {\r\n      throw new Error(`Nonexistent example UID: ${uid}`);\r\n    }\r\n    const label = this.examples[uid].label;\r\n    delete this.examples[uid];\r\n    const index = this.label2Ids[label].indexOf(uid);\r\n    this.label2Ids[label].splice(index, 1);\r\n    if (this.label2Ids[label].length === 0) {\r\n      delete this.label2Ids[label];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the key frame index of a given example.\r\n   *\r\n   * @param uid The UID of the example of which the `keyFrameIndex` is to be\r\n   *   set.\r\n   * @param keyFrameIndex The desired value of the `keyFrameIndex`. Must\r\n   *   be >= 0, < the number of frames of the example, and an integer.\r\n   * @throws Error If the UID and/or the `keyFrameIndex` value is invalid.\r\n   */\r\n  setExampleKeyFrameIndex(uid: string, keyFrameIndex: number) {\r\n    if (!(uid in this.examples)) {\r\n      throw new Error(`Nonexistent example UID: ${uid}`);\r\n    }\r\n    const spectrogram = this.examples[uid].spectrogram;\r\n    const numFrames = spectrogram.data.length / spectrogram.frameSize;\r\n    tf.util.assert(\r\n        keyFrameIndex >= 0 && keyFrameIndex < numFrames &&\r\n            Number.isInteger(keyFrameIndex),\r\n        () => `Invalid keyFrameIndex: ${keyFrameIndex}. ` +\r\n            `Must be >= 0, < ${numFrames}, and an integer.`);\r\n    spectrogram.keyFrameIndex = keyFrameIndex;\r\n  }\r\n\r\n  /**\r\n   * Get the total number of `Example` currently held by the `Dataset`.\r\n   *\r\n   * @returns Total `Example` count.\r\n   */\r\n  size(): number {\r\n    return Object.keys(this.examples).length;\r\n  }\r\n\r\n  /**\r\n   * Get the total duration of the `Example` currently held by `Dataset`,\r\n   *\r\n   * in milliseconds.\r\n   *\r\n   * @return Total duration in milliseconds.\r\n   */\r\n  durationMillis(): number {\r\n    let durMillis = 0;\r\n    const DEFAULT_FRAME_DUR_MILLIS = 23.22;\r\n    for (const key in this.examples) {\r\n      const spectrogram = this.examples[key].spectrogram;\r\n      const frameDurMillis =\r\n          spectrogram.frameDurationMillis | DEFAULT_FRAME_DUR_MILLIS;\r\n      durMillis +=\r\n          spectrogram.data.length / spectrogram.frameSize * frameDurMillis;\r\n    }\r\n    return durMillis;\r\n  }\r\n\r\n  /**\r\n   * Query whether the `Dataset` is currently empty.\r\n   *\r\n   * I.e., holds zero examples.\r\n   *\r\n   * @returns Whether the `Dataset` is currently empty.\r\n   */\r\n  empty(): boolean {\r\n    return this.size() === 0;\r\n  }\r\n\r\n  /**\r\n   * Remove all `Example`s from the `Dataset`.\r\n   */\r\n  clear(): void {\r\n    this.examples = {};\r\n  }\r\n\r\n  /**\r\n   * Get the list of labels among all `Example`s the `Dataset` currently holds.\r\n   *\r\n   * @returns A sorted Array of labels, for the unique labels that belong to all\r\n   *   `Example`s currently held by the `Dataset`.\r\n   */\r\n  getVocabulary(): string[] {\r\n    const vocab = new Set<string>();\r\n    for (const uid in this.examples) {\r\n      const example = this.examples[uid];\r\n      vocab.add(example.label);\r\n    }\r\n    const sortedVocab = [...vocab];\r\n    sortedVocab.sort();\r\n    return sortedVocab;\r\n  }\r\n\r\n  /**\r\n   * Serialize the `Dataset`.\r\n   *\r\n   * The `Examples` are sorted in the following order:\r\n   *   - First, the labels in the vocabulary are sorted.\r\n   *   - Second, the `Example`s for every label are sorted by the order in\r\n   *     which they are added to this `Dataset`.\r\n   *\r\n   * @param wordLabels Optional word label(s) to serialize. If specified, only\r\n   *   the examples with labels matching the argument will be serialized. If\r\n   *   any specified word label does not exist in the vocabulary of this\r\n   *   dataset, an Error will be thrown.\r\n   * @returns A `ArrayBuffer` object amenable to transmission and storage.\r\n   */\r\n  serialize(wordLabels?: string|string[]): ArrayBuffer {\r\n    const vocab = this.getVocabulary();\r\n    tf.util.assert(!this.empty(), () => `Cannot serialize empty Dataset`);\r\n\r\n    if (wordLabels != null) {\r\n      if (!Array.isArray(wordLabels)) {\r\n        wordLabels = [wordLabels];\r\n      }\r\n      wordLabels.forEach(wordLabel => {\r\n        if (vocab.indexOf(wordLabel) === -1) {\r\n          throw new Error(\r\n              `Word label \"${wordLabel}\" does not exist in the ` +\r\n              `vocabulary of this dataset. The vocabulary is: ` +\r\n              `${JSON.stringify(vocab)}.`);\r\n        }\r\n      });\r\n    }\r\n\r\n    const manifest: ExampleSpec[] = [];\r\n    const buffers: ArrayBuffer[] = [];\r\n    for (const label of vocab) {\r\n      if (wordLabels != null && wordLabels.indexOf(label) === -1) {\r\n        continue;\r\n      }\r\n      const ids = this.label2Ids[label];\r\n      for (const id of ids) {\r\n        const artifact = serializeExample(this.examples[id]);\r\n        manifest.push(artifact.spec);\r\n        buffers.push(artifact.data);\r\n      }\r\n    }\r\n    return serializedExamples2ArrayBuffer(\r\n        {manifest, data: concatenateArrayBuffers(buffers)});\r\n  }\r\n}\r\n\r\n/** Serialize an `Example`. */\r\nexport function serializeExample(example: Example):\r\n    {spec: ExampleSpec, data: ArrayBuffer} {\r\n  const hasRawAudio = example.rawAudio != null;\r\n  const spec: ExampleSpec = {\r\n    label: example.label,\r\n    spectrogramNumFrames:\r\n        example.spectrogram.data.length / example.spectrogram.frameSize,\r\n    spectrogramFrameSize: example.spectrogram.frameSize,\r\n  };\r\n  if (example.spectrogram.keyFrameIndex != null) {\r\n    spec.spectrogramKeyFrameIndex = example.spectrogram.keyFrameIndex;\r\n  }\r\n\r\n  let data = example.spectrogram.data.buffer.slice(0);\r\n  if (hasRawAudio) {\r\n    spec.rawAudioNumSamples = example.rawAudio.data.length;\r\n    spec.rawAudioSampleRateHz = example.rawAudio.sampleRateHz;\r\n\r\n    // Account for the fact that the data are all float32.\r\n    data = concatenateArrayBuffers([data, example.rawAudio.data.buffer]);\r\n  }\r\n  return {spec, data};\r\n}\r\n\r\n/** Deserialize an `Example`. */\r\nexport function deserializeExample(\r\n    artifact: {spec: ExampleSpec, data: ArrayBuffer}): Example {\r\n  const spectrogram: SpectrogramData = {\r\n    frameSize: artifact.spec.spectrogramFrameSize,\r\n    data: new Float32Array(artifact.data.slice(\r\n        0,\r\n        4 * artifact.spec.spectrogramFrameSize *\r\n            artifact.spec.spectrogramNumFrames))\r\n  };\r\n  if (artifact.spec.spectrogramKeyFrameIndex != null) {\r\n    spectrogram.keyFrameIndex = artifact.spec.spectrogramKeyFrameIndex;\r\n  }\r\n  const ex: Example = {label: artifact.spec.label, spectrogram};\r\n  if (artifact.spec.rawAudioNumSamples != null) {\r\n    ex.rawAudio = {\r\n      sampleRateHz: artifact.spec.rawAudioSampleRateHz,\r\n      data: new Float32Array(artifact.data.slice(\r\n          4 * artifact.spec.spectrogramFrameSize *\r\n          artifact.spec.spectrogramNumFrames))\r\n    };\r\n  }\r\n  return ex;\r\n}\r\n\r\n/**\r\n * Encode intermediate serialization format as an ArrayBuffer.\r\n *\r\n * Format of the binary ArrayBuffer:\r\n *   1. An 8-byte descriptor (see above).\r\n *   2. A 4-byte version number as Uint32.\r\n *   3. A 4-byte number for the byte length of the JSON manifest.\r\n *   4. The encoded JSON manifest\r\n *   5. The binary data of the spectrograms, and raw audio (if any).\r\n *\r\n * @param serialized: Intermediate serialization format of a dataset.\r\n * @returns The binary conversion result as an ArrayBuffer.\r\n */\r\nfunction serializedExamples2ArrayBuffer(serialized: SerializedExamples):\r\n    ArrayBuffer {\r\n  const manifestBuffer =\r\n      string2ArrayBuffer(JSON.stringify(serialized.manifest));\r\n\r\n  const descriptorBuffer = string2ArrayBuffer(DATASET_SERIALIZATION_DESCRIPTOR);\r\n  const version = new Uint32Array([DATASET_SERIALIZATION_VERSION]);\r\n  const manifestLength = new Uint32Array([manifestBuffer.byteLength]);\r\n  const headerBuffer = concatenateArrayBuffers(\r\n      [descriptorBuffer, version.buffer, manifestLength.buffer]);\r\n\r\n  return concatenateArrayBuffers(\r\n      [headerBuffer, manifestBuffer, serialized.data]);\r\n}\r\n\r\n/** Decode an ArrayBuffer as intermediate serialization format. */\r\nexport function arrayBuffer2SerializedExamples(buffer: ArrayBuffer):\r\n    SerializedExamples {\r\n  tf.util.assert(buffer != null, () => 'Received null or undefined buffer');\r\n  // Check descriptor.\r\n  let offset = 0;\r\n  const descriptor = arrayBuffer2String(\r\n      buffer.slice(offset, DATASET_SERIALIZATION_DESCRIPTOR.length));\r\n  tf.util.assert(\r\n      descriptor === DATASET_SERIALIZATION_DESCRIPTOR,\r\n      () => `Deserialization error: Invalid descriptor`);\r\n  offset += DATASET_SERIALIZATION_DESCRIPTOR.length;\r\n  // Skip the version part for now. It may be used in the future.\r\n  offset += 4;\r\n\r\n  // Extract the length of the encoded manifest JSON as a Uint32.\r\n  const manifestLength = new Uint32Array(buffer, offset, 1);\r\n  offset += 4;\r\n  const manifestBeginByte = offset;\r\n  offset = manifestBeginByte + manifestLength[0];\r\n  const manifestBytes = buffer.slice(manifestBeginByte, offset);\r\n  const manifestString = arrayBuffer2String(manifestBytes);\r\n  const manifest = JSON.parse(manifestString);\r\n  const data = buffer.slice(offset);\r\n  return {manifest, data};\r\n}\r\n\r\n/**\r\n * Get valid windows in a long snippet.\r\n *\r\n * Each window is represented by an inclusive left index and an exclusive\r\n * right index.\r\n *\r\n * @param snippetLength Long of the entire snippet. Must be a positive\r\n *   integer.\r\n * @param focusIndex Optional. If `null` or `undefined`, an array of\r\n *   evenly-spaced windows will be generated. The array of windows will\r\n *   start from the first possible location (i.e., [0, windowLength]).\r\n *   If not `null` or `undefined`, must be an integer >= 0 and < snippetLength.\r\n * @param windowLength Length of each window. Must be a positive integer and\r\n *   <= snippetLength.\r\n * @param windowHop Hops between successsive windows. Must be a positive\r\n *   integer.\r\n * @returns An array of [beginIndex, endIndex] pairs.\r\n */\r\nexport function getValidWindows(\r\n    snippetLength: number, focusIndex: number, windowLength: number,\r\n    windowHop: number): Array<[number, number]> {\r\n  tf.util.assert(\r\n      Number.isInteger(snippetLength) && snippetLength > 0,\r\n      () =>\r\n          `snippetLength must be a positive integer, but got ${snippetLength}`);\r\n  if (focusIndex != null) {\r\n    tf.util.assert(\r\n        Number.isInteger(focusIndex) && focusIndex >= 0,\r\n        () =>\r\n            `focusIndex must be a non-negative integer, but got ${focusIndex}`);\r\n  }\r\n  tf.util.assert(\r\n      Number.isInteger(windowLength) && windowLength > 0,\r\n      () => `windowLength must be a positive integer, but got ${windowLength}`);\r\n  tf.util.assert(\r\n      Number.isInteger(windowHop) && windowHop > 0,\r\n      () => `windowHop must be a positive integer, but got ${windowHop}`);\r\n  tf.util.assert(\r\n      windowLength <= snippetLength,\r\n      () => `windowLength (${windowLength}) exceeds snippetLength ` +\r\n          `(${snippetLength})`);\r\n  tf.util.assert(\r\n      focusIndex < snippetLength,\r\n      () => `focusIndex (${focusIndex}) equals or exceeds snippetLength ` +\r\n          `(${snippetLength})`);\r\n\r\n  if (windowLength === snippetLength) {\r\n    return [[0, snippetLength]];\r\n  }\r\n\r\n  const windows: Array<[number, number]> = [];\r\n\r\n  if (focusIndex == null) {\r\n    // Deal with the special case of no focus frame:\r\n    // Output an array of evenly-spaced windows, starting from\r\n    // the first possible location.\r\n    let begin = 0;\r\n    while (begin + windowLength <= snippetLength) {\r\n      windows.push([begin, begin + windowLength]);\r\n      begin += windowHop;\r\n    }\r\n    return windows;\r\n  }\r\n\r\n  const leftHalf = Math.floor(windowLength / 2);\r\n  let left = focusIndex - leftHalf;\r\n  if (left < 0) {\r\n    left = 0;\r\n  } else if (left + windowLength > snippetLength) {\r\n    left = snippetLength - windowLength;\r\n  }\r\n\r\n  while (true) {\r\n    if (left - windowHop < 0 || focusIndex >= left - windowHop + windowLength) {\r\n      break;\r\n    }\r\n    left -= windowHop;\r\n  }\r\n\r\n  while (left + windowLength <= snippetLength) {\r\n    if (focusIndex < left) {\r\n      break;\r\n    }\r\n    windows.push([left, left + windowLength]);\r\n    left += windowHop;\r\n  }\r\n  return windows;\r\n}\r\n\r\n/**\r\n * Calculate an intensity profile from a spectrogram.\r\n *\r\n * The intensity at each time frame is caclulated by simply averaging all the\r\n * spectral values that belong to that time frame.\r\n *\r\n * @param spectrogram The input spectrogram.\r\n * @returns The temporal profile of the intensity as a 1D tf.Tensor of shape\r\n *   `[numFrames]`.\r\n */\r\nexport function spectrogram2IntensityCurve(spectrogram: SpectrogramData):\r\n    tf.Tensor {\r\n  return tf.tidy(() => {\r\n    const numFrames = spectrogram.data.length / spectrogram.frameSize;\r\n    const x = tf.tensor2d(spectrogram.data, [numFrames, spectrogram.frameSize]);\r\n    return x.mean(-1);\r\n  });\r\n}\r\n\r\n/**\r\n * Get the index to the maximum intensity frame.\r\n *\r\n * The intensity of each time frame is calculated as the arithmetic mean of\r\n * all the spectral values belonging to that time frame.\r\n *\r\n * @param spectrogram The input spectrogram.\r\n * @returns The index to the time frame containing the maximum intensity.\r\n */\r\nexport function getMaxIntensityFrameIndex(spectrogram: SpectrogramData):\r\n    tf.Scalar {\r\n  return tf.tidy(() => spectrogram2IntensityCurve(spectrogram).argMax());\r\n}\r\n","/** @license See the LICENSE file. */\r\n// This code is auto-generated, do not modify this file!\r\nconst version = '0.3.9';\r\nexport {version};\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nimport {BrowserFftFeatureExtractor, SpectrogramCallback} from './browser_fft_extractor';\r\nimport {loadMetadataJson, normalize, normalizeFloat32Array} from './browser_fft_utils';\r\nimport {BACKGROUND_NOISE_TAG, Dataset} from './dataset';\r\nimport {concatenateFloat32Arrays} from './generic_utils';\r\nimport {balancedTrainValSplit} from './training_utils';\r\nimport {AudioDataAugmentationOptions, EvaluateConfig, EvaluateResult, Example, ExampleCollectionOptions, RecognizeConfig, RecognizerCallback, RecognizerParams, ROCCurve, SpectrogramData, SpeechCommandRecognizer, SpeechCommandRecognizerMetadata, SpeechCommandRecognizerResult, StreamingRecognitionConfig, TransferLearnConfig, TransferSpeechCommandRecognizer} from './types';\r\nimport {version} from './version';\r\n\r\nexport const UNKNOWN_TAG = '_unknown_';\r\n\r\n// Key to the local-storage item that holds a map from model name to word\r\n// list.\r\nexport const SAVED_MODEL_METADATA_KEY =\r\n    'tfjs-speech-commands-saved-model-metadata';\r\nexport const SAVE_PATH_PREFIX = 'indexeddb://tfjs-speech-commands-model/';\r\n\r\n// Export a variable for injection during unit testing.\r\n// tslint:disable-next-line:no-any\r\nexport let localStorageWrapper = {\r\n  localStorage: typeof window === 'undefined' ? null : window.localStorage\r\n};\r\n\r\nexport function getMajorAndMinorVersion(version: string) {\r\n  const versionItems = version.split('.');\r\n  return versionItems.slice(0, 2).join('.');\r\n}\r\n\r\n/**\r\n * Default window hop ratio used for extracting multiple\r\n * windows from a long spectrogram.\r\n */\r\nconst DEFAULT_WINDOW_HOP_RATIO = 0.25;\r\n\r\n/**\r\n * Speech-Command Recognizer using browser-native (WebAudio) spectral featutres.\r\n */\r\nexport class BrowserFftSpeechCommandRecognizer implements\r\n    SpeechCommandRecognizer {\r\n  static readonly VALID_VOCABULARY_NAMES: string[] = ['18w', 'directional4w'];\r\n  static readonly DEFAULT_VOCABULARY_NAME = '18w';\r\n\r\n  readonly MODEL_URL_PREFIX =\r\n      `https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v${\r\n          getMajorAndMinorVersion(version)}/browser_fft`;\r\n\r\n  private readonly SAMPLE_RATE_HZ = 44100;\r\n  private readonly FFT_SIZE = 1024;\r\n  private readonly DEFAULT_SUPPRESSION_TIME_MILLIS = 0;\r\n\r\n  model: tf.LayersModel;\r\n  modelWithEmbeddingOutput: tf.LayersModel;\r\n  readonly vocabulary: string;\r\n  readonly parameters: RecognizerParams;\r\n  protected words: string[];\r\n\r\n  protected streaming = false;\r\n\r\n  protected nonBatchInputShape: [number, number, number];\r\n  private elementsPerExample: number;\r\n  protected audioDataExtractor: BrowserFftFeatureExtractor;\r\n\r\n  private transferRecognizers:\r\n      {[name: string]: TransferBrowserFftSpeechCommandRecognizer} = {};\r\n\r\n  private modelArtifactsOrURL: tf.io.ModelArtifacts|string;\r\n  private metadataOrURL: SpeechCommandRecognizerMetadata|string;\r\n\r\n  // The second-last dense layer in the base model.\r\n  // To be used for unfreezing during fine-tuning.\r\n  protected secondLastBaseDenseLayer: tf.layers.Layer;\r\n\r\n  /**\r\n   * Constructor of BrowserFftSpeechCommandRecognizer.\r\n   *\r\n   * @param vocabulary An optional vocabulary specifier. Mutually exclusive\r\n   *   with `modelURL` and `metadataURL`.\r\n   * @param modelArtifactsOrURL An optional, custom model URL pointing to a\r\n   *     model.json, or modelArtifacts in the format of `tf.io.ModelArtifacts`.\r\n   *   file. Supported schemes: http://, https://, and node.js-only: file://.\r\n   *   Mutually exclusive with `vocabulary`. If provided, `metadatURL`\r\n   *   most also be provided.\r\n   * @param metadataOrURL A custom metadata URL pointing to a metadata.json\r\n   *   file. Or it can be a metadata JSON object itself. Must be provided\r\n   *   together with `modelArtifactsOrURL`.\r\n   */\r\n  constructor(\r\n      vocabulary?: string, modelArtifactsOrURL?: tf.io.ModelArtifacts|string,\r\n      metadataOrURL?: SpeechCommandRecognizerMetadata|string) {\r\n    // TODO(cais): Consolidate the fields into a single config object when\r\n    // upgrading to v1.0.\r\n    tf.util.assert(\r\n        modelArtifactsOrURL == null && metadataOrURL == null ||\r\n            modelArtifactsOrURL != null && metadataOrURL != null,\r\n        () => `modelURL and metadataURL must be both provided or ` +\r\n            `both not provided.`);\r\n    if (modelArtifactsOrURL == null) {\r\n      if (vocabulary == null) {\r\n        vocabulary = BrowserFftSpeechCommandRecognizer.DEFAULT_VOCABULARY_NAME;\r\n      } else {\r\n        tf.util.assert(\r\n            BrowserFftSpeechCommandRecognizer.VALID_VOCABULARY_NAMES.indexOf(\r\n                vocabulary) !== -1,\r\n            () => `Invalid vocabulary name: '${vocabulary}'`);\r\n      }\r\n      this.vocabulary = vocabulary;\r\n      this.modelArtifactsOrURL =\r\n          `${this.MODEL_URL_PREFIX}/${this.vocabulary}/model.json`;\r\n      this.metadataOrURL =\r\n          `${this.MODEL_URL_PREFIX}/${this.vocabulary}/metadata.json`;\r\n    } else {\r\n      tf.util.assert(\r\n          vocabulary == null,\r\n          () => `vocabulary name must be null or undefined when modelURL is ` +\r\n              `provided`);\r\n      this.modelArtifactsOrURL = modelArtifactsOrURL;\r\n      this.metadataOrURL = metadataOrURL;\r\n    }\r\n\r\n    this.parameters = {\r\n      sampleRateHz: this.SAMPLE_RATE_HZ,\r\n      fftSize: this.FFT_SIZE\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Start streaming recognition.\r\n   *\r\n   * To stop the recognition, use `stopListening()`.\r\n   *\r\n   * Example: TODO(cais): Add exapmle code snippet.\r\n   *\r\n   * @param callback The callback invoked whenever a word is recognized\r\n   *   with a probability score greater than `config.probabilityThreshold`.\r\n   *   It has the signature:\r\n   *     (result: SpeechCommandRecognizerResult) => Promise<void>\r\n   *   wherein result has the two fields:\r\n   *   - scores: A Float32Array that contains the probability scores for all\r\n   *     the words.\r\n   *   - spectrogram: The spectrogram data, provided only if\r\n   *     `config.includeSpectrogram` is `true`.\r\n   * @param config The configurations for the streaming recognition to\r\n   *   be started.\r\n   *   The `modelName` field of `config` specifies the model to be used for\r\n   *   online recognition. If not specified, it defaults to the name of the\r\n   *   base model ('base'), i.e., the pretrained model not from transfer\r\n   *   learning. If the recognizer instance has one or more transfer-learning\r\n   *   models ready (as a result of calls to `collectTransferExample`\r\n   *   and `trainTransferModel`), you can let this call use that\r\n   *   model for prediction by specifying the corresponding `modelName`.\r\n   * @throws Error, if streaming recognition is already started or\r\n   *   if `config` contains invalid values.\r\n   */\r\n  async listen(\r\n      callback: RecognizerCallback,\r\n      config?: StreamingRecognitionConfig): Promise<void> {\r\n    if (this.streaming) {\r\n      throw new Error(\r\n          'Cannot start streaming again when streaming is ongoing.');\r\n    }\r\n\r\n    await this.ensureModelLoaded();\r\n\r\n    if (config == null) {\r\n      config = {};\r\n    }\r\n    let probabilityThreshold =\r\n        config.probabilityThreshold == null ? 0 : config.probabilityThreshold;\r\n    if (config.includeEmbedding) {\r\n      // Override probability threshold to 0 if includeEmbedding is true.\r\n      probabilityThreshold = 0;\r\n    }\r\n    tf.util.assert(\r\n        probabilityThreshold >= 0 && probabilityThreshold <= 1,\r\n        () => `Invalid probabilityThreshold value: ${probabilityThreshold}`);\r\n    let invokeCallbackOnNoiseAndUnknown =\r\n        config.invokeCallbackOnNoiseAndUnknown == null ?\r\n        false :\r\n        config.invokeCallbackOnNoiseAndUnknown;\r\n    if (config.includeEmbedding) {\r\n      // Override invokeCallbackOnNoiseAndUnknown threshold to true if\r\n      // includeEmbedding is true.\r\n      invokeCallbackOnNoiseAndUnknown = true;\r\n    }\r\n\r\n    if (config.suppressionTimeMillis < 0) {\r\n      throw new Error(\r\n          `suppressionTimeMillis is expected to be >= 0, ` +\r\n          `but got ${config.suppressionTimeMillis}`);\r\n    }\r\n\r\n    const overlapFactor =\r\n        config.overlapFactor == null ? 0.5 : config.overlapFactor;\r\n    tf.util.assert(\r\n        overlapFactor >= 0 && overlapFactor < 1,\r\n        () => `Expected overlapFactor to be >= 0 and < 1, but got ${\r\n            overlapFactor}`);\r\n\r\n    const spectrogramCallback: SpectrogramCallback =\r\n        async (x: tf.Tensor, timeData?: tf.Tensor) => {\r\n      const normalizedX = normalize(x);\r\n      let y: tf.Tensor;\r\n      let embedding: tf.Tensor;\r\n      if (config.includeEmbedding) {\r\n        await this.ensureModelWithEmbeddingOutputCreated();\r\n        [y, embedding] =\r\n            this.modelWithEmbeddingOutput.predict(normalizedX) as tf.Tensor[];\r\n      } else {\r\n        y = this.model.predict(normalizedX) as tf.Tensor;\r\n      }\r\n\r\n      const scores = await y.data() as Float32Array;\r\n      const maxIndexTensor = y.argMax(-1);\r\n      const maxIndex = (await maxIndexTensor.data())[0];\r\n      const maxScore = Math.max(...scores);\r\n      tf.dispose([y, maxIndexTensor, normalizedX]);\r\n\r\n      if (maxScore < probabilityThreshold) {\r\n        return false;\r\n      } else {\r\n        let spectrogram: SpectrogramData = undefined;\r\n        if (config.includeSpectrogram) {\r\n          spectrogram = {\r\n            data: await x.data() as Float32Array,\r\n            frameSize: this.nonBatchInputShape[1],\r\n          };\r\n        }\r\n\r\n        let wordDetected = true;\r\n        if (!invokeCallbackOnNoiseAndUnknown) {\r\n          // Skip background noise and unknown tokens.\r\n          if (this.words[maxIndex] === BACKGROUND_NOISE_TAG ||\r\n              this.words[maxIndex] === UNKNOWN_TAG) {\r\n            wordDetected = false;\r\n          }\r\n        }\r\n        if (wordDetected) {\r\n          callback({scores, spectrogram, embedding});\r\n        }\r\n        // Trigger suppression only if the word is neither unknown or\r\n        // background noise.\r\n        return wordDetected;\r\n      }\r\n    };\r\n\r\n    const suppressionTimeMillis = config.suppressionTimeMillis == null ?\r\n        this.DEFAULT_SUPPRESSION_TIME_MILLIS :\r\n        config.suppressionTimeMillis;\r\n    this.audioDataExtractor = new BrowserFftFeatureExtractor({\r\n      sampleRateHz: this.parameters.sampleRateHz,\r\n      numFramesPerSpectrogram: this.nonBatchInputShape[0],\r\n      columnTruncateLength: this.nonBatchInputShape[1],\r\n      suppressionTimeMillis,\r\n      spectrogramCallback,\r\n      overlapFactor\r\n    });\r\n\r\n    await this.audioDataExtractor.start(config.audioTrackConstraints);\r\n\r\n    this.streaming = true;\r\n  }\r\n\r\n  /**\r\n   * Load the underlying tf.LayersModel instance and associated metadata.\r\n   *\r\n   * If the model and the metadata are already loaded, do nothing.\r\n   */\r\n  async ensureModelLoaded() {\r\n    if (this.model != null) {\r\n      return;\r\n    }\r\n\r\n    await this.ensureMetadataLoaded();\r\n\r\n    let model: tf.LayersModel;\r\n    if (typeof this.modelArtifactsOrURL === 'string') {\r\n      model = await tf.loadLayersModel(this.modelArtifactsOrURL);\r\n    } else {\r\n      // this.modelArtifactsOrURL is an instance of `tf.io.ModelArtifacts`.\r\n      model = await tf.loadLayersModel(tf.io.fromMemory(\r\n          this.modelArtifactsOrURL.modelTopology,\r\n          this.modelArtifactsOrURL.weightSpecs,\r\n          this.modelArtifactsOrURL.weightData));\r\n    }\r\n\r\n    // Check the validity of the model's input shape.\r\n    if (model.inputs.length !== 1) {\r\n      throw new Error(\r\n          `Expected model to have 1 input, but got a model with ` +\r\n          `${model.inputs.length} inputs`);\r\n    }\r\n    if (model.inputs[0].shape.length !== 4) {\r\n      throw new Error(\r\n          `Expected model to have an input shape of rank 4, ` +\r\n          `but got an input shape of rank ${model.inputs[0].shape.length}`);\r\n    }\r\n    if (model.inputs[0].shape[3] !== 1) {\r\n      throw new Error(\r\n          `Expected model to have an input shape with 1 as the last ` +\r\n          `dimension, but got input shape` +\r\n          `${JSON.stringify(model.inputs[0].shape[3])}}`);\r\n    }\r\n    // Check the consistency between the word labels and the model's output\r\n    // shape.\r\n    const outputShape = model.outputShape as tf.Shape;\r\n    if (outputShape.length !== 2) {\r\n      throw new Error(\r\n          `Expected loaded model to have an output shape of rank 2,` +\r\n          `but received shape ${JSON.stringify(outputShape)}`);\r\n    }\r\n    if (outputShape[1] !== this.words.length) {\r\n      throw new Error(\r\n          `Mismatch between the last dimension of model's output shape ` +\r\n          `(${outputShape[1]}) and number of words ` +\r\n          `(${this.words.length}).`);\r\n    }\r\n\r\n    this.model = model;\r\n    this.freezeModel();\r\n\r\n    this.nonBatchInputShape =\r\n        model.inputs[0].shape.slice(1) as [number, number, number];\r\n    this.elementsPerExample = 1;\r\n    model.inputs[0].shape.slice(1).forEach(\r\n        dimSize => this.elementsPerExample *= dimSize);\r\n    this.warmUpModel();\r\n    const frameDurationMillis =\r\n        this.parameters.fftSize / this.parameters.sampleRateHz * 1e3;\r\n    const numFrames = model.inputs[0].shape[1];\r\n    this.parameters.spectrogramDurationMillis = numFrames * frameDurationMillis;\r\n  }\r\n\r\n  /**\r\n   * Construct a two-output model that includes the following outputs:\r\n   *\r\n   * 1. The same softmax probability output as the original model's output\r\n   * 2. The embedding, i.e., activation from the second-last dense layer of\r\n   *    the original model.\r\n   */\r\n  protected async ensureModelWithEmbeddingOutputCreated() {\r\n    if (this.modelWithEmbeddingOutput != null) {\r\n      return;\r\n    }\r\n    await this.ensureModelLoaded();\r\n\r\n    // Find the second last dense layer of the original model.\r\n    let secondLastDenseLayer: tf.layers.Layer;\r\n    for (let i = this.model.layers.length - 2; i >= 0; --i) {\r\n      if (this.model.layers[i].getClassName() === 'Dense') {\r\n        secondLastDenseLayer = this.model.layers[i];\r\n        break;\r\n      }\r\n    }\r\n    if (secondLastDenseLayer == null) {\r\n      throw new Error(\r\n          'Failed to find second last dense layer in the original model.');\r\n    }\r\n    this.modelWithEmbeddingOutput = tf.model({\r\n      inputs: this.model.inputs,\r\n      outputs: [\r\n        this.model.outputs[0], secondLastDenseLayer.output as tf.SymbolicTensor\r\n      ]\r\n    });\r\n  }\r\n\r\n  private warmUpModel() {\r\n    tf.tidy(() => {\r\n      const x = tf.zeros([1].concat(this.nonBatchInputShape));\r\n      for (let i = 0; i < 3; ++i) {\r\n        this.model.predict(x);\r\n      }\r\n    });\r\n  }\r\n\r\n  private async ensureMetadataLoaded() {\r\n    if (this.words != null) {\r\n      return;\r\n    }\r\n\r\n    const metadataJSON = typeof this.metadataOrURL === 'string' ?\r\n        await loadMetadataJson(this.metadataOrURL) :\r\n        this.metadataOrURL;\r\n\r\n    if (metadataJSON.wordLabels == null) {\r\n      // In some legacy formats, the field 'words', instead of 'wordLabels',\r\n      // was populated. This branch ensures backward compatibility with those\r\n      // formats.\r\n      // tslint:disable-next-line:no-any\r\n      const legacyWords = (metadataJSON as any)['words'] as string[];\r\n      if (legacyWords == null) {\r\n        throw new Error(\r\n            'Cannot find field \"words\" or \"wordLabels\" in metadata JSON file');\r\n      }\r\n      this.words = legacyWords;\r\n    } else {\r\n      this.words = metadataJSON.wordLabels;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop streaming recognition.\r\n   *\r\n   * @throws Error if there is not ongoing streaming recognition.\r\n   */\r\n  async stopListening(): Promise<void> {\r\n    if (!this.streaming) {\r\n      throw new Error('Cannot stop streaming when streaming is not ongoing.');\r\n    }\r\n    await this.audioDataExtractor.stop();\r\n    this.streaming = false;\r\n  }\r\n\r\n  /**\r\n   * Check if streaming recognition is ongoing.\r\n   */\r\n  isListening(): boolean {\r\n    return this.streaming;\r\n  }\r\n\r\n  /**\r\n   * Get the array of word labels.\r\n   *\r\n   * @throws Error If this model is called before the model is loaded.\r\n   */\r\n  wordLabels(): string[] {\r\n    return this.words;\r\n  }\r\n\r\n  /**\r\n   * Get the parameters of this instance of BrowserFftSpeechCommandRecognizer.\r\n   *\r\n   * @returns Parameters of this instance.\r\n   */\r\n  params(): RecognizerParams {\r\n    return this.parameters;\r\n  }\r\n\r\n  /**\r\n   * Get the input shape of the underlying tf.LayersModel.\r\n   *\r\n   * @returns The input shape.\r\n   */\r\n  modelInputShape(): tf.Shape {\r\n    if (this.model == null) {\r\n      throw new Error(\r\n          'Model has not been loaded yet. Load model by calling ' +\r\n          'ensureModelLoaded(), recognize(), or listen().');\r\n    }\r\n    return this.model.inputs[0].shape;\r\n  }\r\n\r\n  /**\r\n   * Run offline (non-streaming) recognition on a spectrogram.\r\n   *\r\n   * @param input Spectrogram. Either a `tf.Tensor` of a `Float32Array`.\r\n   *   - If a `tf.Tensor`, must be rank-4 and match the model's expected\r\n   *     input shape in 2nd dimension (# of spectrogram columns), the 3rd\r\n   *     dimension (# of frequency-domain points per column), and the 4th\r\n   *     dimension (always 1). The 1st dimension can be 1, for single-example\r\n   *     recogntion, or any value >1, for batched recognition.\r\n   *   - If a `Float32Array`, must have a length divisible by the number\r\n   *     of elements per spectrogram, i.e.,\r\n   *     (# of spectrogram columns) * (# of frequency-domain points per column).\r\n   * @param config Optional configuration object.\r\n   * @returns Result of the recognition, with the following field:\r\n   *   scores:\r\n   *   - A `Float32Array` if there is only one input exapmle.\r\n   *   - An `Array` of `Float32Array`, if there are multiple input examples.\r\n   */\r\n  async recognize(input?: tf.Tensor|Float32Array, config?: RecognizeConfig):\r\n      Promise<SpeechCommandRecognizerResult> {\r\n    if (config == null) {\r\n      config = {};\r\n    }\r\n\r\n    await this.ensureModelLoaded();\r\n\r\n    if (input == null) {\r\n      // If `input` is not provided, draw audio data from WebAudio and us it\r\n      // for recognition.\r\n      const spectrogramData = await this.recognizeOnline();\r\n      input = spectrogramData.data;\r\n    }\r\n\r\n    let numExamples: number;\r\n    let inputTensor: tf.Tensor;\r\n    let outTensor: tf.Tensor;\r\n    if (input instanceof tf.Tensor) {\r\n      // Check input shape.\r\n      this.checkInputTensorShape(input);\r\n      inputTensor = input;\r\n      numExamples = input.shape[0];\r\n    } else {\r\n      // `input` is a `Float32Array`.\r\n      input = input as Float32Array;\r\n      if (input.length % this.elementsPerExample) {\r\n        throw new Error(\r\n            `The length of the input Float32Array ${input.length} ` +\r\n            `is not divisible by the number of tensor elements per ` +\r\n            `per example expected by the model ${this.elementsPerExample}.`);\r\n      }\r\n\r\n      numExamples = input.length / this.elementsPerExample;\r\n      inputTensor = tf.tensor4d(input, [\r\n        numExamples\r\n      ].concat(this.nonBatchInputShape) as [number, number, number, number]);\r\n    }\r\n\r\n    const output: SpeechCommandRecognizerResult = {scores: null};\r\n    if (config.includeEmbedding) {\r\n      // Optional inclusion of embedding (internal activation).\r\n      await this.ensureModelWithEmbeddingOutputCreated();\r\n      const outAndEmbedding =\r\n          this.modelWithEmbeddingOutput.predict(inputTensor) as tf.Tensor[];\r\n      outTensor = outAndEmbedding[0];\r\n      output.embedding = outAndEmbedding[1];\r\n    } else {\r\n      outTensor = this.model.predict(inputTensor) as tf.Tensor;\r\n    }\r\n\r\n    if (numExamples === 1) {\r\n      output.scores = await outTensor.data() as Float32Array;\r\n    } else {\r\n      const unstacked = tf.unstack(outTensor) as tf.Tensor[];\r\n      const scorePromises = unstacked.map(item => item.data());\r\n      output.scores = await Promise.all(scorePromises) as Float32Array[];\r\n      tf.dispose(unstacked);\r\n    }\r\n\r\n    if (config.includeSpectrogram) {\r\n      output.spectrogram = {\r\n        data: (input instanceof tf.Tensor ? await input.data() : input) as\r\n            Float32Array,\r\n        frameSize: this.nonBatchInputShape[1],\r\n      };\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  private async recognizeOnline(): Promise<SpectrogramData> {\r\n    return new Promise<SpectrogramData>((resolve, reject) => {\r\n      const spectrogramCallback: SpectrogramCallback = async (x: tf.Tensor) => {\r\n        const normalizedX = normalize(x);\r\n        await this.audioDataExtractor.stop();\r\n        resolve({\r\n          data: await normalizedX.data() as Float32Array,\r\n          frameSize: this.nonBatchInputShape[1],\r\n        });\r\n        normalizedX.dispose();\r\n        return false;\r\n      };\r\n      this.audioDataExtractor = new BrowserFftFeatureExtractor({\r\n        sampleRateHz: this.parameters.sampleRateHz,\r\n        numFramesPerSpectrogram: this.nonBatchInputShape[0],\r\n        columnTruncateLength: this.nonBatchInputShape[1],\r\n        suppressionTimeMillis: 0,\r\n        spectrogramCallback,\r\n        overlapFactor: 0\r\n      });\r\n      this.audioDataExtractor.start();\r\n    });\r\n  }\r\n\r\n  createTransfer(name: string): TransferSpeechCommandRecognizer {\r\n    if (this.model == null) {\r\n      throw new Error(\r\n          'Model has not been loaded yet. Load model by calling ' +\r\n          'ensureModelLoaded(), recognizer(), or listen().');\r\n    }\r\n    tf.util.assert(\r\n        name != null && typeof name === 'string' && name.length > 1,\r\n        () => `Expected the name for a transfer-learning recognized to be a ` +\r\n            `non-empty string, but got ${JSON.stringify(name)}`);\r\n    tf.util.assert(\r\n        this.transferRecognizers[name] == null,\r\n        () => `There is already a transfer-learning model named '${name}'`);\r\n    const transfer = new TransferBrowserFftSpeechCommandRecognizer(\r\n        name, this.parameters, this.model);\r\n    this.transferRecognizers[name] = transfer;\r\n    return transfer;\r\n  }\r\n\r\n  protected freezeModel(): void {\r\n    for (const layer of this.model.layers) {\r\n      layer.trainable = false;\r\n    }\r\n  }\r\n\r\n  private checkInputTensorShape(input: tf.Tensor) {\r\n    const expectedRank = this.model.inputs[0].shape.length;\r\n    if (input.shape.length !== expectedRank) {\r\n      throw new Error(\r\n          `Expected input Tensor to have rank ${expectedRank}, ` +\r\n          `but got rank ${input.shape.length} that differs `);\r\n    }\r\n    const nonBatchedShape = input.shape.slice(1);\r\n    const expectedNonBatchShape = this.model.inputs[0].shape.slice(1);\r\n    if (!tf.util.arraysEqual(nonBatchedShape, expectedNonBatchShape)) {\r\n      throw new Error(\r\n          `Expected input to have shape [null,${expectedNonBatchShape}], ` +\r\n          `but got shape [null,${nonBatchedShape}]`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * A subclass of BrowserFftSpeechCommandRecognizer: Transfer-learned model.\r\n */\r\nclass TransferBrowserFftSpeechCommandRecognizer extends\r\n    BrowserFftSpeechCommandRecognizer implements\r\n        TransferSpeechCommandRecognizer {\r\n  private dataset: Dataset;\r\n  private transferHead: tf.Sequential;\r\n\r\n  /**\r\n   * Constructor of TransferBrowserFftSpeechCommandRecognizer.\r\n   *\r\n   * @param name Name of the transfer-learned recognizer. Must be a non-empty\r\n   *   string.\r\n   * @param parameters Parameters from the base recognizer.\r\n   * @param baseModel Model from the base recognizer.\r\n   */\r\n  constructor(\r\n      readonly name: string, readonly parameters: RecognizerParams,\r\n      readonly baseModel: tf.LayersModel) {\r\n    super();\r\n    tf.util.assert(\r\n        name != null && typeof name === 'string' && name.length > 0,\r\n        () => `The name of a transfer model must be a non-empty string, ` +\r\n            `but got ${JSON.stringify(name)}`);\r\n    this.nonBatchInputShape =\r\n        this.baseModel.inputs[0].shape.slice(1) as [number, number, number];\r\n    this.words = null;\r\n    this.dataset = new Dataset();\r\n  }\r\n\r\n  /**\r\n   * Collect an example for transfer learning via WebAudio.\r\n   *\r\n   * @param {string} word Name of the word. Must not overlap with any of the\r\n   *   words the base model is trained to recognize.\r\n   * @param {ExampleCollectionOptions}\r\n   * @returns {SpectrogramData} The spectrogram of the acquired the example.\r\n   * @throws Error, if word belongs to the set of words the base model is\r\n   *   trained to recognize.\r\n   */\r\n  async collectExample(word: string, options?: ExampleCollectionOptions):\r\n      Promise<SpectrogramData> {\r\n    tf.util.assert(\r\n        !this.streaming,\r\n        () => 'Cannot start collection of transfer-learning example because ' +\r\n            'a streaming recognition or transfer-learning example collection ' +\r\n            'is ongoing');\r\n    tf.util.assert(\r\n        word != null && typeof word === 'string' && word.length > 0,\r\n        () => `Must provide a non-empty string when collecting transfer-` +\r\n            `learning example`);\r\n\r\n    if (options == null) {\r\n      options = {};\r\n    }\r\n    if (options.durationMultiplier != null && options.durationSec != null) {\r\n      throw new Error(\r\n          `durationMultiplier and durationSec are mutually exclusive, ` +\r\n          `but are both specified.`);\r\n    }\r\n\r\n    let numFramesPerSpectrogram: number;\r\n    if (options.durationSec != null) {\r\n      tf.util.assert(\r\n          options.durationSec > 0,\r\n          () =>\r\n              `Expected durationSec to be > 0, but got ${options.durationSec}`);\r\n      const frameDurationSec =\r\n          this.parameters.fftSize / this.parameters.sampleRateHz;\r\n      numFramesPerSpectrogram =\r\n          Math.ceil(options.durationSec / frameDurationSec);\r\n    } else if (options.durationMultiplier != null) {\r\n      tf.util.assert(\r\n          options.durationMultiplier >= 1,\r\n          () => `Expected duration multiplier to be >= 1, ` +\r\n              `but got ${options.durationMultiplier}`);\r\n      numFramesPerSpectrogram =\r\n          Math.round(this.nonBatchInputShape[0] * options.durationMultiplier);\r\n    } else {\r\n      numFramesPerSpectrogram = this.nonBatchInputShape[0];\r\n    }\r\n\r\n    if (options.snippetDurationSec != null) {\r\n      tf.util.assert(\r\n          options.snippetDurationSec > 0,\r\n          () => `snippetDurationSec is expected to be > 0, but got ` +\r\n              `${options.snippetDurationSec}`);\r\n      tf.util.assert(\r\n          options.onSnippet != null,\r\n          () => `onSnippet must be provided if snippetDurationSec ` +\r\n              `is provided.`);\r\n    }\r\n    if (options.onSnippet != null) {\r\n      tf.util.assert(\r\n          options.snippetDurationSec != null,\r\n          () => `snippetDurationSec must be provided if onSnippet ` +\r\n              `is provided.`);\r\n    }\r\n    const frameDurationSec =\r\n        this.parameters.fftSize / this.parameters.sampleRateHz;\r\n    const totalDurationSec = frameDurationSec * numFramesPerSpectrogram;\r\n\r\n    this.streaming = true;\r\n    return new Promise<SpectrogramData>(resolve => {\r\n      const stepFactor = options.snippetDurationSec == null ?\r\n          1 :\r\n          options.snippetDurationSec / totalDurationSec;\r\n      const overlapFactor = 1 - stepFactor;\r\n      const callbackCountTarget = Math.round(1 / stepFactor);\r\n      let callbackCount = 0;\r\n      let lastIndex = -1;\r\n      const spectrogramSnippets: Float32Array[] = [];\r\n\r\n      const spectrogramCallback: SpectrogramCallback =\r\n          async (freqData: tf.Tensor, timeData?: tf.Tensor) => {\r\n        // TODO(cais): can we consolidate the logic in the two branches?\r\n        if (options.onSnippet == null) {\r\n          const normalizedX = normalize(freqData);\r\n          this.dataset.addExample({\r\n            label: word,\r\n            spectrogram: {\r\n              data: await normalizedX.data() as Float32Array,\r\n              frameSize: this.nonBatchInputShape[1],\r\n            },\r\n            rawAudio: options.includeRawAudio ? {\r\n              data: await timeData.data() as Float32Array,\r\n              sampleRateHz: this.audioDataExtractor.sampleRateHz\r\n            } :\r\n                                                undefined\r\n          });\r\n          normalizedX.dispose();\r\n          await this.audioDataExtractor.stop();\r\n          this.streaming = false;\r\n          this.collateTransferWords();\r\n          resolve({\r\n            data: await freqData.data() as Float32Array,\r\n            frameSize: this.nonBatchInputShape[1],\r\n          });\r\n        } else {\r\n          const data = await freqData.data() as Float32Array;\r\n          if (lastIndex === -1) {\r\n            lastIndex = data.length;\r\n          }\r\n          let i = lastIndex - 1;\r\n          while (data[i] !== 0 && i >= 0) {\r\n            i--;\r\n          }\r\n          const increment = lastIndex - i - 1;\r\n          lastIndex = i + 1;\r\n          const snippetData = data.slice(data.length - increment, data.length);\r\n          spectrogramSnippets.push(snippetData);\r\n\r\n          if (options.onSnippet != null) {\r\n            options.onSnippet(\r\n                {data: snippetData, frameSize: this.nonBatchInputShape[1]});\r\n          }\r\n\r\n          if (callbackCount++ === callbackCountTarget) {\r\n            await this.audioDataExtractor.stop();\r\n            this.streaming = false;\r\n            this.collateTransferWords();\r\n\r\n            const normalized = normalizeFloat32Array(\r\n                concatenateFloat32Arrays(spectrogramSnippets));\r\n            const finalSpectrogram: SpectrogramData = {\r\n              data: normalized,\r\n              frameSize: this.nonBatchInputShape[1]\r\n            };\r\n            this.dataset.addExample({\r\n              label: word,\r\n              spectrogram: finalSpectrogram,\r\n              rawAudio: options.includeRawAudio ? {\r\n                data: await timeData.data() as Float32Array,\r\n                sampleRateHz: this.audioDataExtractor.sampleRateHz\r\n              } :\r\n                                                  undefined\r\n            });\r\n            // TODO(cais): Fix 1-tensor memory leak.\r\n            resolve(finalSpectrogram);\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      this.audioDataExtractor = new BrowserFftFeatureExtractor({\r\n        sampleRateHz: this.parameters.sampleRateHz,\r\n        numFramesPerSpectrogram,\r\n        columnTruncateLength: this.nonBatchInputShape[1],\r\n        suppressionTimeMillis: 0,\r\n        spectrogramCallback,\r\n        overlapFactor,\r\n        includeRawAudio: options.includeRawAudio\r\n      });\r\n      this.audioDataExtractor.start(options.audioTrackConstraints);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear all transfer learning examples collected so far.\r\n   */\r\n  clearExamples(): void {\r\n    tf.util.assert(\r\n        this.words != null && this.words.length > 0 && !this.dataset.empty(),\r\n        () =>\r\n            `No transfer learning examples exist for model name ${this.name}`);\r\n    this.dataset.clear();\r\n    this.words = null;\r\n  }\r\n\r\n  /**\r\n   * Get counts of the word examples that have been collected for a\r\n   * transfer-learning model.\r\n   *\r\n   * @returns {{[word: string]: number}} A map from word name to number of\r\n   *   examples collected for that word so far.\r\n   */\r\n  countExamples(): {[word: string]: number} {\r\n    if (this.dataset.empty()) {\r\n      throw new Error(\r\n          `No examples have been collected for transfer-learning model ` +\r\n          `named '${this.name}' yet.`);\r\n    }\r\n    return this.dataset.getExampleCounts();\r\n  }\r\n\r\n  /**\r\n   * Get examples currently held by the transfer-learning recognizer.\r\n   *\r\n   * @param label Label requested.\r\n   * @returns An array of `Example`s, along with their UIDs.\r\n   */\r\n  getExamples(label: string): Array<{uid: string, example: Example}> {\r\n    return this.dataset.getExamples(label);\r\n  }\r\n\r\n  /** Set the key frame index of a given example. */\r\n  setExampleKeyFrameIndex(uid: string, keyFrameIndex: number): void {\r\n    this.dataset.setExampleKeyFrameIndex(uid, keyFrameIndex);\r\n  }\r\n\r\n  /**\r\n   * Remove an example from the current dataset.\r\n   *\r\n   * @param uid The UID of the example to remove.\r\n   */\r\n  removeExample(uid: string): void {\r\n    this.dataset.removeExample(uid);\r\n    this.collateTransferWords();\r\n  }\r\n\r\n  /**\r\n   * Check whether the underlying dataset is empty.\r\n   *\r\n   * @returns A boolean indicating whether the underlying dataset is empty.\r\n   */\r\n  isDatasetEmpty(): boolean {\r\n    return this.dataset.empty();\r\n  }\r\n\r\n  /**\r\n   * Load an array of serialized examples.\r\n   *\r\n   * @param serialized The examples in their serialized format.\r\n   * @param clearExisting Whether to clear the existing examples while\r\n   *   performing the loading (default: false).\r\n   */\r\n  loadExamples(serialized: ArrayBuffer, clearExisting = false): void {\r\n    const incomingDataset = new Dataset(serialized);\r\n    if (clearExisting) {\r\n      this.clearExamples();\r\n    }\r\n\r\n    const incomingVocab = incomingDataset.getVocabulary();\r\n    for (const label of incomingVocab) {\r\n      const examples = incomingDataset.getExamples(label);\r\n      for (const example of examples) {\r\n        this.dataset.addExample(example.example);\r\n      }\r\n    }\r\n\r\n    this.collateTransferWords();\r\n  }\r\n\r\n  /**\r\n   * Serialize the existing examples.\r\n   *\r\n   * @param wordLabels Optional word label(s) to serialize. If specified, only\r\n   *   the examples with labels matching the argument will be serialized. If\r\n   *   any specified word label does not exist in the vocabulary of this\r\n   *   transfer recognizer, an Error will be thrown.\r\n   * @returns An `ArrayBuffer` object amenable to transmission and storage.\r\n   */\r\n  serializeExamples(wordLabels?: string|string[]): ArrayBuffer {\r\n    return this.dataset.serialize(wordLabels);\r\n  }\r\n\r\n  /**\r\n   * Collect the vocabulary of this transfer-learned recognizer.\r\n   *\r\n   * The words are put in an alphabetically sorted order.\r\n   */\r\n  private collateTransferWords() {\r\n    this.words = this.dataset.getVocabulary();\r\n  }\r\n\r\n  /**\r\n   * Collect the transfer-learning data as `tf.Tensor`s.\r\n   *\r\n   * Used for training and evaluation when the amount of data is relatively\r\n   * small.\r\n   *\r\n   * @param windowHopRatio Ratio betwen hop length in number of frames and the\r\n   *   number of frames in a long spectrogram. Used during extraction\r\n   *   of multiple windows from the long spectrogram.\r\n   * @returns xs: The feature tensors (xs), a 4D tf.Tensor.\r\n   *          ys: The target tensors (ys), one-hot encoding, a 2D tf.Tensor.\r\n   */\r\n  private collectTransferDataAsTensors(\r\n      windowHopRatio?: number,\r\n      augmentationOptions?: AudioDataAugmentationOptions):\r\n      {xs: tf.Tensor, ys: tf.Tensor} {\r\n    const numFrames = this.nonBatchInputShape[0];\r\n    windowHopRatio = windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\r\n    const hopFrames = Math.round(windowHopRatio * numFrames);\r\n    const out = this.dataset.getData(\r\n                    null, {numFrames, hopFrames, ...augmentationOptions}) as\r\n        {xs: tf.Tensor4D, ys?: tf.Tensor2D};\r\n    return {xs: out.xs, ys: out.ys as tf.Tensor};\r\n  }\r\n\r\n  /**\r\n   * Same as `collectTransferDataAsTensors`, but returns `tf.data.Dataset`s.\r\n   *\r\n   * Used for training and evaluation when the amount of data is large.\r\n   *\r\n   * @param windowHopRatio Ratio betwen hop length in number of frames and the\r\n   *   number of frames in a long spectrogram. Used during extraction\r\n   *   of multiple windows from the long spectrogram.\r\n   * @param validationSplit The validation split to be used for splitting\r\n   *   the raw data between the `tf.data.Dataset` objects for training and\r\n   *   validation.\r\n   * @param batchSize Batch size used for the `tf.data.Dataset.batch()` call\r\n   *   during the creation of the dataset objects.\r\n   * @return Two `tf.data.Dataset` objects, one for training and one for\r\n   *   validation. Each of the objects may be directly fed into\r\n   *   `this.model.fitDataset`.\r\n   */\r\n  private collectTransferDataAsTfDataset(\r\n      windowHopRatio?: number, validationSplit = 0.15, batchSize = 32,\r\n      augmentationOptions?: AudioDataAugmentationOptions):\r\n      [tf.data.Dataset<{}>, tf.data.Dataset<{}>] {\r\n    const numFrames = this.nonBatchInputShape[0];\r\n    windowHopRatio = windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\r\n    const hopFrames = Math.round(windowHopRatio * numFrames);\r\n    return this.dataset.getData(null, {\r\n      numFrames,\r\n      hopFrames,\r\n      getDataset: true,\r\n      datasetBatchSize: batchSize,\r\n      datasetValidationSplit: validationSplit,\r\n      ...augmentationOptions\r\n    }) as [tf.data.Dataset<{}>, tf.data.Dataset<{}>];\r\n    // TODO(cais): See if we can tighten the typing.\r\n  }\r\n\r\n  /**\r\n   * Train the transfer-learning model.\r\n   *\r\n   * The last dense layer of the base model is replaced with new softmax dense\r\n   * layer.\r\n   *\r\n   * It is assume that at least one category of data has been collected (using\r\n   * multiple calls to the `collectTransferExample` method).\r\n   *\r\n   * @param config {TransferLearnConfig} Optional configurations fot the\r\n   *   training of the transfer-learning model.\r\n   * @returns {tf.History} A history object with the loss and accuracy values\r\n   *   from the training of the transfer-learning model.\r\n   * @throws Error, if `modelName` is invalid or if not sufficient training\r\n   *   examples have been collected yet.\r\n   */\r\n  async train(config?: TransferLearnConfig):\r\n      Promise<tf.History|[tf.History, tf.History]> {\r\n    tf.util.assert(\r\n        this.words != null && this.words.length > 0,\r\n        () =>\r\n            `Cannot train transfer-learning model '${this.name}' because no ` +\r\n            `transfer learning example has been collected.`);\r\n    tf.util.assert(\r\n        this.words.length > 1,\r\n        () => `Cannot train transfer-learning model '${\r\n                  this.name}' because only ` +\r\n            `1 word label ('${JSON.stringify(this.words)}') ` +\r\n            `has been collected for transfer learning. Requires at least 2.`);\r\n    if (config.fineTuningEpochs != null) {\r\n      tf.util.assert(\r\n          config.fineTuningEpochs >= 0 &&\r\n              Number.isInteger(config.fineTuningEpochs),\r\n          () => `If specified, fineTuningEpochs must be a non-negative ` +\r\n              `integer, but received ${config.fineTuningEpochs}`);\r\n    }\r\n\r\n    if (config == null) {\r\n      config = {};\r\n    }\r\n\r\n    if (this.model == null) {\r\n      this.createTransferModelFromBaseModel();\r\n    }\r\n\r\n    // This layer needs to be frozen for the initial phase of the\r\n    // transfer learning. During subsequent fine-tuning (if any), it will\r\n    // be unfrozen.\r\n    this.secondLastBaseDenseLayer.trainable = false;\r\n\r\n    // Compile model for training.\r\n    this.model.compile({\r\n      loss: 'categoricalCrossentropy',\r\n      optimizer: config.optimizer || 'sgd',\r\n      metrics: ['acc']\r\n    });\r\n\r\n    // Use `tf.data.Dataset` objects for training of the total duration of\r\n    // the recordings exceeds 60 seconds. Otherwise, use `tf.Tensor` objects.\r\n    const datasetDurationMillisThreshold =\r\n        config.fitDatasetDurationMillisThreshold == null ?\r\n        60e3 :\r\n        config.fitDatasetDurationMillisThreshold;\r\n    if (this.dataset.durationMillis() > datasetDurationMillisThreshold) {\r\n      console.log(\r\n          `Detected large dataset: total duration = ` +\r\n          `${this.dataset.durationMillis()} ms > ` +\r\n          `${datasetDurationMillisThreshold} ms. ` +\r\n          `Training transfer model using fitDataset() instead of fit()`);\r\n      return await this.trainOnDataset(config);\r\n    } else {\r\n      return await this.trainOnTensors(config);\r\n    }\r\n  }\r\n\r\n  /** Helper function for training on tf.data.Dataset objects. */\r\n  private async trainOnDataset(config?: TransferLearnConfig):\r\n      Promise<tf.History|[tf.History, tf.History]> {\r\n    tf.util.assert(config.epochs > 0, () => `Invalid config.epochs`);\r\n    // Train transfer-learning model using fitDataset\r\n\r\n    const batchSize = config.batchSize == null ? 32 : config.batchSize;\r\n    const windowHopRatio = config.windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\r\n    const [trainDataset, valDataset] = this.collectTransferDataAsTfDataset(\r\n        windowHopRatio, config.validationSplit, batchSize,\r\n        {augmentByMixingNoiseRatio: config.augmentByMixingNoiseRatio});\r\n    const t0 = tf.util.now();\r\n    const history = await this.model.fitDataset(trainDataset, {\r\n      epochs: config.epochs,\r\n      validationData: config.validationSplit > 0 ? valDataset : null,\r\n      callbacks: config.callback == null ? null : [config.callback]\r\n    });\r\n    console.log(`fitDataset() took ${(tf.util.now() - t0).toFixed(2)} ms`);\r\n\r\n    if (config.fineTuningEpochs != null && config.fineTuningEpochs > 0) {\r\n      // Perform fine-tuning.\r\n      const t0 = tf.util.now();\r\n      const fineTuningHistory = await this.fineTuningUsingTfDatasets(\r\n          config, trainDataset, valDataset);\r\n      console.log(\r\n          `fitDataset() (fine-tuning) took ` +\r\n          `${(tf.util.now() - t0).toFixed(2)} ms`);\r\n      return [history, fineTuningHistory];\r\n    } else {\r\n      return history;\r\n    }\r\n  }\r\n\r\n  /** Helper function for training on tf.Tensor objects. */\r\n  private async trainOnTensors(config?: TransferLearnConfig):\r\n      Promise<tf.History|[tf.History, tf.History]> {\r\n    // Prepare the data.\r\n    const windowHopRatio = config.windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\r\n    const {xs, ys} = this.collectTransferDataAsTensors(\r\n        windowHopRatio,\r\n        {augmentByMixingNoiseRatio: config.augmentByMixingNoiseRatio});\r\n    console.log(\r\n        `Training data: xs.shape = ${xs.shape}, ys.shape = ${ys.shape}`);\r\n\r\n    let trainXs: tf.Tensor;\r\n    let trainYs: tf.Tensor;\r\n    let valData: [tf.Tensor, tf.Tensor];\r\n    try {\r\n      // TODO(cais): The balanced split may need to be pushed down to the\r\n      //   level of the Dataset class to avoid leaks between train and val\r\n      //   splits.\r\n      if (config.validationSplit != null) {\r\n        const splits = balancedTrainValSplit(xs, ys, config.validationSplit);\r\n        trainXs = splits.trainXs;\r\n        trainYs = splits.trainYs;\r\n        valData = [splits.valXs, splits.valYs];\r\n      } else {\r\n        trainXs = xs;\r\n        trainYs = ys;\r\n      }\r\n\r\n      const history = await this.model.fit(trainXs, trainYs, {\r\n        epochs: config.epochs == null ? 20 : config.epochs,\r\n        validationData: valData,\r\n        batchSize: config.batchSize,\r\n        callbacks: config.callback == null ? null : [config.callback]\r\n      });\r\n\r\n      if (config.fineTuningEpochs != null && config.fineTuningEpochs > 0) {\r\n        // Fine tuning: unfreeze the second-last dense layer of the base\r\n        // model.\r\n        const fineTuningHistory = await this.fineTuningUsingTensors(\r\n            config, trainXs, trainYs, valData);\r\n        return [history, fineTuningHistory];\r\n      } else {\r\n        return history;\r\n      }\r\n    } finally {\r\n      tf.dispose([xs, ys, trainXs, trainYs, valData]);\r\n    }\r\n  }\r\n\r\n  private async fineTuningUsingTfDatasets(\r\n      config: TransferLearnConfig, trainDataset: tf.data.Dataset<{}>,\r\n      valDataset: tf.data.Dataset<{}>): Promise<tf.History> {\r\n    const originalTrainableValue = this.secondLastBaseDenseLayer.trainable;\r\n    this.secondLastBaseDenseLayer.trainable = true;\r\n\r\n    // Recompile model after unfreezing layer.\r\n    const fineTuningOptimizer: string|tf.Optimizer =\r\n        config.fineTuningOptimizer == null ? 'sgd' : config.fineTuningOptimizer;\r\n    this.model.compile({\r\n      loss: 'categoricalCrossentropy',\r\n      optimizer: fineTuningOptimizer,\r\n      metrics: ['acc']\r\n    });\r\n\r\n    const fineTuningHistory = await this.model.fitDataset(trainDataset, {\r\n      epochs: config.fineTuningEpochs,\r\n      validationData: valDataset,\r\n      callbacks: config.callback == null ? null : [config.callback]\r\n    });\r\n    // Set the trainable attribute of the fine-tuning layer to its\r\n    // previous value.\r\n    this.secondLastBaseDenseLayer.trainable = originalTrainableValue;\r\n    return fineTuningHistory;\r\n  }\r\n\r\n  private async fineTuningUsingTensors(\r\n      config: TransferLearnConfig, trainXs: tf.Tensor, trainYs: tf.Tensor,\r\n      valData: [tf.Tensor, tf.Tensor]): Promise<tf.History> {\r\n    const originalTrainableValue = this.secondLastBaseDenseLayer.trainable;\r\n    this.secondLastBaseDenseLayer.trainable = true;\r\n\r\n    // Recompile model after unfreezing layer.\r\n    const fineTuningOptimizer: string|tf.Optimizer =\r\n        config.fineTuningOptimizer == null ? 'sgd' : config.fineTuningOptimizer;\r\n    this.model.compile({\r\n      loss: 'categoricalCrossentropy',\r\n      optimizer: fineTuningOptimizer,\r\n      metrics: ['acc']\r\n    });\r\n\r\n    const fineTuningHistory = await this.model.fit(trainXs, trainYs, {\r\n      epochs: config.fineTuningEpochs,\r\n      validationData: valData,\r\n      batchSize: config.batchSize,\r\n      callbacks: config.fineTuningCallback == null ? null :\r\n                                                     [config.fineTuningCallback]\r\n    });\r\n    // Set the trainable attribute of the fine-tuning layer to its\r\n    // previous value.\r\n    this.secondLastBaseDenseLayer.trainable = originalTrainableValue;\r\n    return fineTuningHistory;\r\n  }\r\n\r\n  /**\r\n   * Perform evaluation of the model using the examples that the model\r\n   * has loaded.\r\n   *\r\n   * @param config Configuration object for the evaluation.\r\n   * @returns A Promise of the result of evaluation.\r\n   */\r\n  async evaluate(config: EvaluateConfig): Promise<EvaluateResult> {\r\n    tf.util.assert(\r\n        config.wordProbThresholds != null &&\r\n            config.wordProbThresholds.length > 0,\r\n        () => `Received null or empty wordProbThresholds`);\r\n\r\n    // TODO(cais): Maybe relax this requirement.\r\n    const NOISE_CLASS_INDEX = 0;\r\n    tf.util.assert(\r\n        this.words[NOISE_CLASS_INDEX] === BACKGROUND_NOISE_TAG,\r\n        () => `Cannot perform evaluation when the first tag is not ` +\r\n            `${BACKGROUND_NOISE_TAG}`);\r\n\r\n    return tf.tidy(() => {\r\n      const rocCurve: ROCCurve = [];\r\n      let auc = 0;\r\n      const {xs, ys} = this.collectTransferDataAsTensors(config.windowHopRatio);\r\n      const indices = ys.argMax(-1).dataSync();\r\n      const probs = this.model.predict(xs) as tf.Tensor;\r\n\r\n      // To calcaulte ROC, we collapse all word probabilites into a single\r\n      // positive class, while _background_noise_ is treated as the\r\n      // negative class.\r\n      const maxWordProbs =\r\n          probs.slice([0, 1], [probs.shape[0], probs.shape[1] - 1]).max(-1);\r\n      const total = probs.shape[0];\r\n\r\n      // Calculate ROC curve.\r\n      for (let i = 0; i < config.wordProbThresholds.length; ++i) {\r\n        const probThreshold = config.wordProbThresholds[i];\r\n        const isWord =\r\n            maxWordProbs.greater(tf.scalar(probThreshold)).dataSync();\r\n\r\n        let negatives = 0;\r\n        let positives = 0;\r\n        let falsePositives = 0;\r\n        let truePositives = 0;\r\n        for (let i = 0; i < total; ++i) {\r\n          if (indices[i] === NOISE_CLASS_INDEX) {\r\n            negatives++;\r\n            if (isWord[i]) {\r\n              falsePositives++;\r\n            }\r\n          } else {\r\n            positives++;\r\n            if (isWord[i]) {\r\n              truePositives++;\r\n            }\r\n          }\r\n        }\r\n\r\n        // TODO(cais): Calculate per-hour false-positive rate.\r\n        const fpr = falsePositives / negatives;\r\n        const tpr = truePositives / positives;\r\n\r\n        rocCurve.push({probThreshold, fpr, tpr});\r\n        console.log(\r\n            `ROC thresh=${probThreshold}: ` +\r\n            `fpr=${fpr.toFixed(4)}, tpr=${tpr.toFixed(4)}`);\r\n\r\n        if (i > 0) {\r\n          // Accumulate to AUC.\r\n          auc += Math.abs((rocCurve[i - 1].fpr - rocCurve[i].fpr)) *\r\n              (rocCurve[i - 1].tpr + rocCurve[i].tpr) / 2;\r\n        }\r\n      }\r\n      return {rocCurve, auc};\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create an instance of tf.LayersModel for transfer learning.\r\n   *\r\n   * The top dense layer of the base model is replaced with a new softmax\r\n   * dense layer.\r\n   */\r\n  private createTransferModelFromBaseModel(): void {\r\n    tf.util.assert(\r\n        this.words != null,\r\n        () =>\r\n            `No word example is available for tranfer-learning model of name ` +\r\n            this.name);\r\n\r\n    // Find the second last dense layer.\r\n    const layers = this.baseModel.layers;\r\n    let layerIndex = layers.length - 2;\r\n    while (layerIndex >= 0) {\r\n      if (layers[layerIndex].getClassName().toLowerCase() === 'dense') {\r\n        break;\r\n      }\r\n      layerIndex--;\r\n    }\r\n    if (layerIndex < 0) {\r\n      throw new Error('Cannot find a hidden dense layer in the base model.');\r\n    }\r\n    this.secondLastBaseDenseLayer = layers[layerIndex];\r\n    const truncatedBaseOutput =\r\n        this.secondLastBaseDenseLayer.output as tf.SymbolicTensor;\r\n\r\n    this.transferHead = tf.sequential();\r\n    this.transferHead.add(tf.layers.dense({\r\n      units: this.words.length,\r\n      activation: 'softmax',\r\n      inputShape: truncatedBaseOutput.shape.slice(1),\r\n      name: 'NewHeadDense'\r\n    }));\r\n    const transferOutput =\r\n        this.transferHead.apply(truncatedBaseOutput) as tf.SymbolicTensor;\r\n    this.model =\r\n        tf.model({inputs: this.baseModel.inputs, outputs: transferOutput});\r\n  }\r\n\r\n  /**\r\n   * Get the input shape of the underlying tf.LayersModel.\r\n   *\r\n   * @returns The input shape.\r\n   */\r\n  modelInputShape(): tf.Shape {\r\n    return this.baseModel.inputs[0].shape;\r\n  }\r\n\r\n  getMetadata(): SpeechCommandRecognizerMetadata {\r\n    return {\r\n      tfjsSpeechCommandsVersion: version,\r\n      modelName: this.name,\r\n      timeStamp: new Date().toISOString(),\r\n      wordLabels: this.wordLabels()\r\n    };\r\n  }\r\n\r\n  async save(handlerOrURL?: string|tf.io.IOHandler): Promise<tf.io.SaveResult> {\r\n    const isCustomPath = handlerOrURL != null;\r\n    handlerOrURL = handlerOrURL || getCanonicalSavePath(this.name);\r\n\r\n    if (!isCustomPath) {\r\n      // First, save the words and other metadata.\r\n      const metadataMapStr =\r\n          localStorageWrapper.localStorage.getItem(SAVED_MODEL_METADATA_KEY);\r\n      const metadataMap =\r\n          metadataMapStr == null ? {} : JSON.parse(metadataMapStr);\r\n      metadataMap[this.name] = this.getMetadata();\r\n      localStorageWrapper.localStorage.setItem(\r\n          SAVED_MODEL_METADATA_KEY, JSON.stringify(metadataMap));\r\n    }\r\n    console.log(`Saving model to ${handlerOrURL}`);\r\n    return this.model.save(handlerOrURL);\r\n  }\r\n\r\n  async load(handlerOrURL?: string|tf.io.IOHandler): Promise<void> {\r\n    const isCustomPath = handlerOrURL != null;\r\n    handlerOrURL = handlerOrURL || getCanonicalSavePath(this.name);\r\n\r\n    if (!isCustomPath) {\r\n      // First, load the words and other metadata.\r\n      const metadataMap = JSON.parse(\r\n          localStorageWrapper.localStorage.getItem(SAVED_MODEL_METADATA_KEY));\r\n      if (metadataMap == null || metadataMap[this.name] == null) {\r\n        throw new Error(\r\n            `Cannot find metadata for transfer model named ${this.name}\"`);\r\n      }\r\n      this.words = metadataMap[this.name].wordLabels;\r\n      console.log(\r\n          `Loaded word list for model named ${this.name}: ${this.words}`);\r\n    }\r\n    this.model = await tf.loadLayersModel(handlerOrURL);\r\n    console.log(`Loaded model from ${handlerOrURL}:`);\r\n    this.model.summary();\r\n  }\r\n\r\n  /**\r\n   * Overridden method to prevent creating a nested transfer-learning\r\n   * recognizer.\r\n   *\r\n   * @param name\r\n   */\r\n  createTransfer(name: string): TransferBrowserFftSpeechCommandRecognizer {\r\n    throw new Error(\r\n        'Creating transfer-learned recognizer from a transfer-learned ' +\r\n        'recognizer is not supported.');\r\n  }\r\n}\r\n\r\nfunction getCanonicalSavePath(name: string): string {\r\n  return `${SAVE_PATH_PREFIX}${name}`;\r\n}\r\n\r\n/**\r\n * List the model that are currently saved locally in the browser.\r\n *\r\n * @returns An array of transfer-learned speech-commands models\r\n *   that are currently saved in the browser locally.\r\n */\r\nexport async function listSavedTransferModels(): Promise<string[]> {\r\n  const models = await tf.io.listModels();\r\n  const keys = [];\r\n  for (const key in models) {\r\n    if (key.startsWith(SAVE_PATH_PREFIX)) {\r\n      keys.push(key.slice(SAVE_PATH_PREFIX.length));\r\n    }\r\n  }\r\n  return keys;\r\n}\r\n\r\n/**\r\n * Delete a locally-saved, transfer-learned speech-commands model.\r\n *\r\n * @param name The name of the transfer-learned model to be deleted.\r\n */\r\nexport async function deleteSavedTransferModel(name: string): Promise<void> {\r\n  // Delete the words from local storage.\r\n  let metadataMap = JSON.parse(\r\n      localStorageWrapper.localStorage.getItem(SAVED_MODEL_METADATA_KEY));\r\n  if (metadataMap == null) {\r\n    metadataMap = {};\r\n  }\r\n  if (metadataMap[name] != null) {\r\n    delete metadataMap[name];\r\n  }\r\n  localStorageWrapper.localStorage.setItem(\r\n      SAVED_MODEL_METADATA_KEY, JSON.stringify(metadataMap));\r\n  await tf.io.removeModel(getCanonicalSavePath(name));\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nimport {BrowserFftSpeechCommandRecognizer} from './browser_fft_recognizer';\r\nimport {playRawAudio} from './browser_fft_utils';\r\nimport {concatenateFloat32Arrays} from './generic_utils';\r\nimport {FFT_TYPE, SpeechCommandRecognizer, SpeechCommandRecognizerMetadata} from './types';\r\n\r\n/**\r\n * Create an instance of speech-command recognizer.\r\n *\r\n * @param fftType Type of FFT. The currently availble option(s):\r\n *   - BROWSER_FFT: Obtains audio spectrograms using browser's native Fourier\r\n *     transform.\r\n * @param vocabulary The vocabulary of the model to load. Possible options:\r\n *   - '18w' (default): The 18-word vocaulbary, consisting of:\r\n *     'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\r\n *     'eight', 'nine', 'up', 'down', 'left', 'right', 'go', 'stop',\r\n *     'yes', and 'no', in addition to '_background_noise_' and '_unknown_'.\r\n *   - 'directional4w': The four directional words: 'up', 'down', 'left', and\r\n *     'right', in addition to '_background_noise_' and '_unknown_'.\r\n *   Choosing a smaller vocabulary leads to better accuracy on the words of\r\n *   interest and a slightly smaller model size.\r\n * @param customModelArtifactsOrURL A custom model URL pointing to a model.json\r\n *     file, or a set of modelArtifacts in `tf.io.ModelArtifacts` format.\r\n *   Supported schemes: http://, https://, and node.js-only: file://.\r\n *   Mutually exclusive with `vocabulary`. If provided, `customMetadatURL`\r\n *   most also be provided.\r\n * @param customMetadataOrURL A custom metadata URL pointing to a metadata.json\r\n *   file. Must be provided together with `customModelURL`, or a metadata\r\n *   object.\r\n * @returns An instance of SpeechCommandRecognizer.\r\n * @throws Error on invalid value of `fftType`.\r\n */\r\nexport function create(\r\n    fftType: FFT_TYPE, vocabulary?: string,\r\n    customModelArtifactsOrURL?: tf.io.ModelArtifacts|string,\r\n    customMetadataOrURL?: SpeechCommandRecognizerMetadata|\r\n    string): SpeechCommandRecognizer {\r\n  tf.util.assert(\r\n      customModelArtifactsOrURL == null && customMetadataOrURL == null ||\r\n          customModelArtifactsOrURL != null && customMetadataOrURL != null,\r\n      () => `customModelURL and customMetadataURL must be both provided or ` +\r\n          `both not provided.`);\r\n  if (customModelArtifactsOrURL != null) {\r\n    tf.util.assert(\r\n        vocabulary == null,\r\n        () => `vocabulary name must be null or undefined when modelURL ` +\r\n            `is provided.`);\r\n  }\r\n\r\n  if (fftType === 'BROWSER_FFT') {\r\n    return new BrowserFftSpeechCommandRecognizer(\r\n        vocabulary, customModelArtifactsOrURL, customMetadataOrURL);\r\n  } else if (fftType === 'SOFT_FFT') {\r\n    throw new Error(\r\n        'SOFT_FFT SpeechCommandRecognizer has not been implemented yet.');\r\n  } else {\r\n    throw new Error(`Invalid fftType: '${fftType}'`);\r\n  }\r\n}\r\n\r\nconst utils = {\r\n  concatenateFloat32Arrays,\r\n  playRawAudio\r\n};\r\n\r\nexport {BACKGROUND_NOISE_TAG, Dataset, GetDataConfig as GetSpectrogramsAsTensorsConfig, getMaxIntensityFrameIndex, spectrogram2IntensityCurve, SpectrogramAndTargetsTfDataset} from './dataset';\r\nexport {AudioDataAugmentationOptions, Example, FFT_TYPE, RawAudioData, RecognizerParams, SpectrogramData, SpeechCommandRecognizer, SpeechCommandRecognizerMetadata, SpeechCommandRecognizerResult, StreamingRecognitionConfig, TransferLearnConfig, TransferSpeechCommandRecognizer} from './types';\r\nexport {deleteSavedTransferModel, listSavedTransferModels, UNKNOWN_TAG} from './browser_fft_recognizer';\r\nexport {utils};\r\nexport {version} from './version';\r\n"],"names":["tf.backend","tf.tidy","tf.util","tf.dispose","tf.tensor","tf.gather","tslib_1.__values","tf.tensor3d","tf.data","tf.oneHot","tf.tensor1d","tf.stack","tf.tensor2d","version","tf.loadLayersModel","tf.io","tf.model","tf.zeros","tf.Tensor","tf.tensor4d","tf.unstack","tslib_1.__extends","tslib_1.__read","tf.scalar","tf.sequential","tf.layers"],"mappings":"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"}